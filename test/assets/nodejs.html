<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>all - Node.js v0.6.7 Manual &amp; Documentation</title>
  <link rel="stylesheet" href="assets/style.css">
  <link rel="stylesheet" href="assets/sh.css">
  <link rel="canonical" href="http://nodejs.org/docs/latest/api/all.html">
</head>
<body>
  <div id="container">
    <header>
      <h1>Node.js v0.6.7 Manual &amp; Documentation</h1>
      <div id="gtoc">
        <p><a href="index.html">Index</a> | <a href="all.html">View on single page</a></p>
      </div>
      <hr>
    </header>
    <div id="toc"><h2>Table Of Contents</h2><ul><li><a href="#synopsis">Synopsis</a></li><li><a href="#global_Objects">Global Objects</a><ul><li><a href="#global">global</a></li><li><a href="#process">process</a></li><li><a href="#console">console</a></li><li><a href="#buffer">Buffer</a></li><li><a href="#require">require()</a></li><li><a href="#require.resolve">require.resolve()</a></li><li><a href="#require.cache">require.cache</a></li><li><a href="#__filename">__filename</a></li><li><a href="#__dirname">__dirname</a></li><li><a href="#module">module</a></li><li><a href="#exports">exports</a></li><li><a href="#setTimeout">setTimeout(cb, ms)</a></li><li><a href="#clearTimeout">clearTimeout(t)</a></li><li><a href="#setInterval">setInterval(cb, ms)</a></li><li><a href="#clearInterval">clearInterval(t)</a></li></ul></li><li><a href="#console">console</a><ul><li><a href="#console.log">console.log()</a></li><li><a href="#console.info">console.info()</a></li><li><a href="#console.warn">console.warn()</a></li><li><a href="#console.error">console.error()</a></li><li><a href="#console.dir">console.dir(obj)</a></li><li><a href="#console.time">console.time(label)</a></li><li><a href="#console.timeEnd">console.timeEnd(label)</a></li><li><a href="#console.trace">console.trace()</a></li><li><a href="#console.assert">console.assert()</a></li></ul></li><li><a href="#timers">Timers</a><ul><li><a href="#setTimeout">setTimeout(callback, delay, [arg], [...])</a></li><li><a href="#clearTimeout">clearTimeout(timeoutId)</a></li><li><a href="#setInterval">setInterval(callback, delay, [arg], [...])</a></li><li><a href="#clearInterval">clearInterval(intervalId)</a></li></ul></li><li><a href="#modules">Modules</a><ul><li><a href="#cycles">Cycles</a></li><li><a href="#core_Modules">Core Modules</a></li><li><a href="#file_Modules">File Modules</a></li><li><a href="#loading_from_node_modules_Folders">Loading from `node_modules` Folders</a></li><li><a href="#folders_as_Modules">Folders as Modules</a></li><li><a href="#caching">Caching</a><ul><li><a href="#module_Caching_Caveats">Module Caching Caveats</a></li></ul></li><li><a href="#module.exports">module.exports</a></li><li><a href="#module.require">module.require</a></li><li><a href="#all_Together...">All Together...</a></li><li><a href="#loading_from_the_global_folders">Loading from the global folders</a></li><li><a href="#accessing_the_main_module">Accessing the main module</a></li></ul></li><li><a href="#addenda_Package_Manager_Tips">Addenda: Package Manager Tips</a></li><li><a href="#addons">Addons</a></li><li><a href="#process">process</a><ul><li><a href="#event_exit_">Event: 'exit'</a></li><li><a href="#event_uncaughtException_">Event: 'uncaughtException'</a></li><li><a href="#signal_Events">Signal Events</a></li><li><a href="#process.stdout">process.stdout</a></li><li><a href="#process.stderr">process.stderr</a></li><li><a href="#process.stdin">process.stdin</a></li><li><a href="#process.argv">process.argv</a></li><li><a href="#process.execPath">process.execPath</a></li><li><a href="#process.chdir">process.chdir(directory)</a></li><li><a href="#process.cwd">process.cwd()</a></li><li><a href="#process.env">process.env</a></li><li><a href="#process.exit">process.exit([code])</a></li><li><a href="#process.getgid">process.getgid()</a></li><li><a href="#process.setgid">process.setgid(id)</a></li><li><a href="#process.getuid">process.getuid()</a></li><li><a href="#process.setuid">process.setuid(id)</a></li><li><a href="#process.version">process.version</a></li><li><a href="#process.versions">process.versions</a></li><li><a href="#process.installPrefix">process.installPrefix</a></li><li><a href="#process.kill">process.kill(pid, [signal])</a></li><li><a href="#process.pid">process.pid</a></li><li><a href="#process.title">process.title</a></li><li><a href="#process.arch">process.arch</a></li><li><a href="#process.platform">process.platform</a></li><li><a href="#process.memoryUsage">process.memoryUsage()</a></li><li><a href="#process.nextTick">process.nextTick(callback)</a></li><li><a href="#process.umask">process.umask([mask])</a></li><li><a href="#process.uptime">process.uptime()</a></li></ul></li><li><a href="#util">util</a><ul><li><a href="#util.format">util.format()</a></li><li><a href="#util.debug">util.debug(string)</a></li><li><a href="#util.log">util.log(string)</a></li><li><a href="#util.inspect">util.inspect(object, [showHidden], [depth], [colors])</a></li><li><a href="#util.isArray">util.isArray(object)</a></li><li><a href="#util.isRegExp">util.isRegExp(object)</a></li><li><a href="#util.isDate">util.isDate(object)</a></li><li><a href="#util.isError">util.isError(object)</a></li><li><a href="#util.pump">util.pump(readableStream, writableStream, [callback])</a></li><li><a href="#util.inherits">util.inherits(constructor, superConstructor)</a></li></ul></li><li><a href="#events">Events</a><ul><li><a href="#events.EventEmitter">events.EventEmitter</a><ul><li><a href="#emitter.addListener">emitter.addListener(event, listener)</a></li><li><a href="#emitter.on">emitter.on(event, listener)</a></li><li><a href="#emitter.once">emitter.once(event, listener)</a></li><li><a href="#emitter.removeListener">emitter.removeListener(event, listener)</a></li><li><a href="#emitter.removeAllListeners">emitter.removeAllListeners([event])</a></li><li><a href="#emitter.setMaxListeners">emitter.setMaxListeners(n)</a></li><li><a href="#emitter.listeners">emitter.listeners(event)</a></li><li><a href="#emitter.emit">emitter.emit(event, [arg1], [arg2], [...])</a></li><li><a href="#event_newListener_">Event: 'newListener'</a></li></ul></li></ul></li><li><a href="#buffers">Buffers</a><ul><li><a href="#new_Buffer">new Buffer(size)</a></li><li><a href="#new_Buffer">new Buffer(array)</a></li><li><a href="#new_Buffer">new Buffer(str, [encoding])</a></li><li><a href="#buffer.write">buffer.write(string, [offset], [length], [encoding])</a></li><li><a href="#buffer.toString">buffer.toString(encoding, [start], [end])</a></li><li><a href="#buffer_index_">buffer[index]</a></li><li><a href="#buffer.isBuffer">Buffer.isBuffer(obj)</a></li><li><a href="#buffer.byteLength">Buffer.byteLength(string, [encoding])</a></li><li><a href="#buffer.length">buffer.length</a></li><li><a href="#buffer.copy">buffer.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])</a></li><li><a href="#buffer.slice">buffer.slice([start], [end])</a></li><li><a href="#buffer.readUInt8">buffer.readUInt8(offset, [noAssert])</a></li><li><a href="#buffer.readUInt16LE">buffer.readUInt16LE(offset, [noAssert])</a></li><li><a href="#buffer.readUInt16BE">buffer.readUInt16BE(offset, [noAssert])</a></li><li><a href="#buffer.readUInt32LE">buffer.readUInt32LE(offset, [noAssert])</a></li><li><a href="#buffer.readUInt32BE">buffer.readUInt32BE(offset, [noAssert])</a></li><li><a href="#buffer.readInt8">buffer.readInt8(offset, [noAssert])</a></li><li><a href="#buffer.readInt16LE">buffer.readInt16LE(offset, [noAssert])</a></li><li><a href="#buffer.readInt16BE">buffer.readInt16BE(offset, [noAssert])</a></li><li><a href="#buffer.readInt32LE">buffer.readInt32LE(offset, [noAssert])</a></li><li><a href="#buffer.readInt32BE">buffer.readInt32BE(offset, [noAssert])</a></li><li><a href="#buffer.readFloatLE">buffer.readFloatLE(offset, [noAssert])</a></li><li><a href="#buffer.readFloatBE">buffer.readFloatBE(offset, [noAssert])</a></li><li><a href="#buffer.readDoubleLE">buffer.readDoubleLE(offset, [noAssert])</a></li><li><a href="#buffer.readDoubleBE">buffer.readDoubleBE(offset, [noAssert])</a></li><li><a href="#buffer.writeUInt8">buffer.writeUInt8(value, offset, [noAssert])</a></li><li><a href="#buffer.writeUInt16LE">buffer.writeUInt16LE(value, offset, [noAssert])</a></li><li><a href="#buffer.writeUInt16BE">buffer.writeUInt16BE(value, offset, [noAssert])</a></li><li><a href="#buffer.writeUInt32LE">buffer.writeUInt32LE(value, offset, [noAssert])</a></li><li><a href="#buffer.writeUInt32BE">buffer.writeUInt32BE(value, offset, [noAssert])</a></li><li><a href="#buffer.writeInt8">buffer.writeInt8(value, offset, [noAssert])</a></li><li><a href="#buffer.writeInt16LE">buffer.writeInt16LE(value, offset, [noAssert])</a></li><li><a href="#buffer.writeInt16BE">buffer.writeInt16BE(value, offset, [noAssert])</a></li><li><a href="#buffer.writeInt32LE">buffer.writeInt32LE(value, offset, [noAssert])</a></li><li><a href="#buffer.writeInt32BE">buffer.writeInt32BE(value, offset, [noAssert])</a></li><li><a href="#buffer.writeFloatLE">buffer.writeFloatLE(value, offset, [noAssert])</a></li><li><a href="#buffer.writeFloatBE">buffer.writeFloatBE(value, offset, [noAssert])</a></li><li><a href="#buffer.writeDoubleLE">buffer.writeDoubleLE(value, offset, [noAssert])</a></li><li><a href="#buffer.writeDoubleBE">buffer.writeDoubleBE(value, offset, [noAssert])</a></li><li><a href="#buffer.fill">buffer.fill(value, [offset], [end])</a></li><li><a href="#iNSPECT_MAX_BYTES">INSPECT_MAX_BYTES</a></li></ul></li><li><a href="#streams">Streams</a></li><li><a href="#readable_Stream">Readable Stream</a><ul><li><a href="#event_data_">Event: 'data'</a></li><li><a href="#event_end_">Event: 'end'</a></li><li><a href="#event_error_">Event: 'error'</a></li><li><a href="#event_close_">Event: 'close'</a></li><li><a href="#stream.readable">stream.readable</a></li><li><a href="#stream.setEncoding">stream.setEncoding(encoding)</a></li><li><a href="#stream.pause">stream.pause()</a></li><li><a href="#stream.resume">stream.resume()</a></li><li><a href="#stream.destroy">stream.destroy()</a></li><li><a href="#stream.destroySoon">stream.destroySoon()</a></li><li><a href="#stream.pipe">stream.pipe(destination, [options])</a></li></ul></li><li><a href="#writable_Stream">Writable Stream</a><ul><li><a href="#event_drain_">Event: 'drain'</a></li><li><a href="#event_error_">Event: 'error'</a></li><li><a href="#event_close_">Event: 'close'</a></li><li><a href="#event_pipe_">Event: 'pipe'</a></li><li><a href="#stream.writable">stream.writable</a></li><li><a href="#stream.write">stream.write(string, [encoding], [fd])</a></li><li><a href="#stream.write">stream.write(buffer)</a></li><li><a href="#stream.end">stream.end()</a></li><li><a href="#stream.end">stream.end(string, encoding)</a></li><li><a href="#stream.end">stream.end(buffer)</a></li><li><a href="#stream.destroy">stream.destroy()</a></li><li><a href="#stream.destroySoon">stream.destroySoon()</a></li></ul></li><li><a href="#crypto">Crypto</a><ul><li><a href="#crypto.createCredentials">crypto.createCredentials(details)</a></li><li><a href="#crypto.createHash">crypto.createHash(algorithm)</a></li><li><a href="#hash.update">hash.update(data, [input_encoding])</a></li><li><a href="#hash.digest">hash.digest([encoding])</a></li><li><a href="#crypto.createHmac">crypto.createHmac(algorithm, key)</a></li><li><a href="#hmac.update">hmac.update(data)</a></li><li><a href="#hmac.digest">hmac.digest([encoding])</a></li><li><a href="#crypto.createCipher">crypto.createCipher(algorithm, password)</a></li><li><a href="#crypto.createCipheriv">crypto.createCipheriv(algorithm, key, iv)</a></li><li><a href="#cipher.update">cipher.update(data, [input_encoding], [output_encoding])</a></li><li><a href="#cipher.final">cipher.final([output_encoding])</a></li><li><a href="#crypto.createDecipher">crypto.createDecipher(algorithm, password)</a></li><li><a href="#crypto.createDecipheriv">crypto.createDecipheriv(algorithm, key, iv)</a></li><li><a href="#decipher.update">decipher.update(data, [input_encoding], [output_encoding])</a></li><li><a href="#decipher.final">decipher.final([output_encoding])</a></li><li><a href="#crypto.createSign">crypto.createSign(algorithm)</a></li><li><a href="#signer.update">signer.update(data)</a></li><li><a href="#signer.sign">signer.sign(private_key, [output_format])</a></li><li><a href="#crypto.createVerify">crypto.createVerify(algorithm)</a></li><li><a href="#verifier.update">verifier.update(data)</a></li><li><a href="#verifier.verify">verifier.verify(object, signature, [signature_format])</a></li><li><a href="#crypto.createDiffieHellman">crypto.createDiffieHellman(prime_length)</a></li><li><a href="#crypto.createDiffieHellman">crypto.createDiffieHellman(prime, [encoding])</a></li><li><a href="#diffieHellman.generateKeys">diffieHellman.generateKeys([encoding])</a></li><li><a href="#diffieHellman.computeSecret">diffieHellman.computeSecret(other_public_key, [input_encoding], [output_encoding])</a></li><li><a href="#diffieHellman.getPrime">diffieHellman.getPrime([encoding])</a></li><li><a href="#diffieHellman.getGenerator">diffieHellman.getGenerator([encoding])</a></li><li><a href="#diffieHellman.getPublicKey">diffieHellman.getPublicKey([encoding])</a></li><li><a href="#diffieHellman.getPrivateKey">diffieHellman.getPrivateKey([encoding])</a></li><li><a href="#diffieHellman.setPublicKey">diffieHellman.setPublicKey(public_key, [encoding])</a></li><li><a href="#diffieHellman.setPrivateKey">diffieHellman.setPrivateKey(public_key, [encoding])</a></li><li><a href="#pbkdf2">pbkdf2(password, salt, iterations, keylen, callback)</a></li><li><a href="#randomBytes">randomBytes(size, [callback])</a></li></ul></li><li><a href="#tLS_">TLS (SSL)</a><ul><li><a href="#tls.createServer">tls.createServer(options, [secureConnectionListener])</a></li><li><a href="#tls.connect">tls.connect(port, [host], [options], [secureConnectListener])</a></li></ul></li><li><a href="#sTARTTLS">STARTTLS</a></li><li><a href="#nPN_and_SNI">NPN and SNI</a></li><li><a href="#pair_tls.createSecurePair">pair = tls.createSecurePair([credentials], [isServer], [requestCert], [rejectUnauthorized])</a><ul><li><a href="#event_secure_">Event: 'secure'</a></li></ul></li><li><a href="#tls.Server">tls.Server</a><ul><li><a href="#event_secureConnection_">Event: 'secureConnection'</a></li></ul></li><li><a href="#event_clientError_">Event: 'clientError'</a><ul><li><a href="#server.listen">server.listen(port, [host], [callback])</a></li><li><a href="#server.close">server.close()</a></li><li><a href="#server.address">server.address()</a></li><li><a href="#server.addContext">server.addContext(hostname, credentials)</a></li><li><a href="#server.maxConnections">server.maxConnections</a></li><li><a href="#server.connections">server.connections</a></li></ul></li><li><a href="#tls.CleartextStream">tls.CleartextStream</a><ul><li><a href="#event_secureConnect_">Event: 'secureConnect'</a></li><li><a href="#cleartextStream.authorized">cleartextStream.authorized</a></li><li><a href="#cleartextStream.authorizationError">cleartextStream.authorizationError</a></li><li><a href="#cleartextStream.getPeerCertificate">cleartextStream.getPeerCertificate()</a></li><li><a href="#cleartextStream.address">cleartextStream.address()</a></li><li><a href="#cleartextStream.remoteAddress">cleartextStream.remoteAddress</a></li><li><a href="#cleartextStream.remotePort">cleartextStream.remotePort</a></li></ul></li></ul></li><li><a href="#file_System">File System</a><ul><li><a href="#fs.rename">fs.rename(path1, path2, [callback])</a></li><li><a href="#fs.renameSync">fs.renameSync(path1, path2)</a></li><li><a href="#fs.truncate">fs.truncate(fd, len, [callback])</a></li><li><a href="#fs.truncateSync">fs.truncateSync(fd, len)</a></li><li><a href="#fs.chown">fs.chown(path, uid, gid, [callback])</a></li><li><a href="#fs.chownSync">fs.chownSync(path, uid, gid)</a></li><li><a href="#fs.fchown">fs.fchown(fd, uid, gid, [callback])</a></li><li><a href="#fs.fchownSync">fs.fchownSync(fd, uid, gid)</a></li><li><a href="#fs.lchown">fs.lchown(path, uid, gid, [callback])</a></li><li><a href="#fs.lchownSync">fs.lchownSync(path, uid, gid)</a></li><li><a href="#fs.chmod">fs.chmod(path, mode, [callback])</a></li><li><a href="#fs.chmodSync">fs.chmodSync(path, mode)</a></li><li><a href="#fs.fchmod">fs.fchmod(fd, mode, [callback])</a></li><li><a href="#fs.fchmodSync">fs.fchmodSync(fd, mode)</a></li><li><a href="#fs.lchmod">fs.lchmod(path, mode, [callback])</a></li><li><a href="#fs.lchmodSync">fs.lchmodSync(path, mode)</a></li><li><a href="#fs.stat">fs.stat(path, [callback])</a></li><li><a href="#fs.lstat">fs.lstat(path, [callback])</a></li><li><a href="#fs.fstat">fs.fstat(fd, [callback])</a></li><li><a href="#fs.statSync">fs.statSync(path)</a></li><li><a href="#fs.lstatSync">fs.lstatSync(path)</a></li><li><a href="#fs.fstatSync">fs.fstatSync(fd)</a></li><li><a href="#fs.link">fs.link(srcpath, dstpath, [callback])</a></li><li><a href="#fs.linkSync">fs.linkSync(srcpath, dstpath)</a></li><li><a href="#fs.symlink">fs.symlink(linkdata, path, [type], [callback])</a></li><li><a href="#fs.symlinkSync">fs.symlinkSync(linkdata, path, [type])</a></li><li><a href="#fs.readlink">fs.readlink(path, [callback])</a></li><li><a href="#fs.readlinkSync">fs.readlinkSync(path)</a></li><li><a href="#fs.realpath">fs.realpath(path, [callback])</a></li><li><a href="#fs.realpathSync">fs.realpathSync(path)</a></li><li><a href="#fs.unlink">fs.unlink(path, [callback])</a></li><li><a href="#fs.unlinkSync">fs.unlinkSync(path)</a></li><li><a href="#fs.rmdir">fs.rmdir(path, [callback])</a></li><li><a href="#fs.rmdirSync">fs.rmdirSync(path)</a></li><li><a href="#fs.mkdir">fs.mkdir(path, [mode], [callback])</a></li><li><a href="#fs.mkdirSync">fs.mkdirSync(path, [mode])</a></li><li><a href="#fs.readdir">fs.readdir(path, [callback])</a></li><li><a href="#fs.readdirSync">fs.readdirSync(path)</a></li><li><a href="#fs.close">fs.close(fd, [callback])</a></li><li><a href="#fs.closeSync">fs.closeSync(fd)</a></li><li><a href="#fs.open">fs.open(path, flags, [mode], [callback])</a></li><li><a href="#fs.openSync">fs.openSync(path, flags, [mode])</a></li><li><a href="#fs.utimes">fs.utimes(path, atime, mtime, [callback])</a></li><li><a href="#fs.utimesSync">fs.utimesSync(path, atime, mtime)</a></li><li><a href="#fs.futimes">fs.futimes(fd, atime, mtime, [callback])</a></li><li><a href="#fs.futimesSync">fs.futimesSync(fd, atime, mtime)</a></li><li><a href="#fs.fsync">fs.fsync(fd, [callback])</a></li><li><a href="#fs.fsyncSync">fs.fsyncSync(fd)</a></li><li><a href="#fs.write">fs.write(fd, buffer, offset, length, position, [callback])</a></li><li><a href="#fs.writeSync">fs.writeSync(fd, buffer, offset, length, position)</a></li><li><a href="#fs.writeSync">fs.writeSync(fd, str, position, [encoding])</a></li><li><a href="#fs.read">fs.read(fd, buffer, offset, length, position, [callback])</a></li><li><a href="#fs.readSync">fs.readSync(fd, buffer, offset, length, position)</a></li><li><a href="#fs.readSync">fs.readSync(fd, length, position, encoding)</a></li><li><a href="#fs.readFile">fs.readFile(filename, [encoding], [callback])</a></li><li><a href="#fs.readFileSync">fs.readFileSync(filename, [encoding])</a></li><li><a href="#fs.writeFile">fs.writeFile(filename, data, [encoding], [callback])</a></li><li><a href="#fs.writeFileSync">fs.writeFileSync(filename, data, [encoding])</a></li><li><a href="#fs.watchFile">fs.watchFile(filename, [options], listener)</a></li><li><a href="#fs.unwatchFile">fs.unwatchFile(filename)</a></li><li><a href="#fs.watch">fs.watch(filename, [options], listener)</a></li></ul></li><li><a href="#fs.Stats">fs.Stats</a></li><li><a href="#fs.ReadStream">fs.ReadStream</a><ul><li><a href="#event_open_">Event: 'open'</a></li><li><a href="#fs.createReadStream">fs.createReadStream(path, [options])</a></li></ul></li><li><a href="#fs.WriteStream">fs.WriteStream</a><ul><li><a href="#event_open_">Event: 'open'</a></li><li><a href="#file.bytesWritten">file.bytesWritten</a></li><li><a href="#fs.createWriteStream">fs.createWriteStream(path, [options])</a></li></ul></li><li><a href="#fs.FSWatcher">fs.FSWatcher</a><ul><li><a href="#watcher.close">watcher.close()</a></li><li><a href="#event_change_">Event: 'change'</a></li><li><a href="#event_error_">Event: 'error'</a></li></ul></li></ul></li><li><a href="#path">Path</a><ul><li><a href="#path.normalize">path.normalize(p)</a></li><li><a href="#path.join">path.join([path1], [path2], [...])</a></li><li><a href="#path.resolve">path.resolve([from ...], to)</a></li><li><a href="#path.relative">path.relative(from, to)</a></li><li><a href="#path.dirname">path.dirname(p)</a></li><li><a href="#path.basename">path.basename(p, [ext])</a></li><li><a href="#path.extname">path.extname(p)</a></li><li><a href="#path.exists">path.exists(p, [callback])</a></li><li><a href="#path.existsSync">path.existsSync(p)</a></li></ul></li><li><a href="#net">net</a><ul><li><a href="#net.createServer">net.createServer([options], [connectionListener])</a></li><li><a href="#net.connect">net.connect(arguments...)</a></li><li><a href="#net.createConnection">net.createConnection(arguments...)</a></li><li><a href="#net.Server">net.Server</a><ul><li><a href="#server.listen">server.listen(port, [host], [listeningListener])</a></li><li><a href="#server.listen">server.listen(path, [listeningListener])</a></li><li><a href="#server.pause">server.pause(msecs)</a></li><li><a href="#server.close">server.close()</a></li><li><a href="#server.address">server.address()</a></li><li><a href="#server.maxConnections">server.maxConnections</a></li><li><a href="#server.connections">server.connections</a></li><li><a href="#event_listening_">Event: 'listening'</a></li><li><a href="#event_connection_">Event: 'connection'</a></li><li><a href="#event_close_">Event: 'close'</a></li><li><a href="#event_error_">Event: 'error'</a></li></ul></li><li><a href="#net.Socket">net.Socket</a><ul><li><a href="#new_net.Socket">new net.Socket([options])</a></li><li><a href="#socket.connect">socket.connect(port, [host], [connectListener])</a></li><li><a href="#socket.connect">socket.connect(path, [connectListener])</a></li><li><a href="#socket.bufferSize">socket.bufferSize</a></li><li><a href="#socket.setEncoding">socket.setEncoding([encoding])</a></li><li><a href="#socket.setSecure">socket.setSecure()</a></li><li><a href="#socket.write">socket.write(data, [encoding], [callback])</a></li><li><a href="#socket.write">socket.write(data, [encoding], [callback])</a></li><li><a href="#socket.end">socket.end([data], [encoding])</a></li><li><a href="#socket.destroy">socket.destroy()</a></li><li><a href="#socket.pause">socket.pause()</a></li><li><a href="#socket.resume">socket.resume()</a></li><li><a href="#socket.setTimeout">socket.setTimeout(timeout, [callback])</a></li><li><a href="#socket.setNoDelay">socket.setNoDelay([noDelay])</a></li><li><a href="#socket.setKeepAlive">socket.setKeepAlive([enable], [initialDelay])</a></li><li><a href="#socket.address">socket.address()</a></li><li><a href="#socket.remoteAddress">socket.remoteAddress</a></li><li><a href="#socket.remotePort">socket.remotePort</a></li><li><a href="#socket.bytesRead">socket.bytesRead</a></li><li><a href="#socket.bytesWritten">socket.bytesWritten</a></li><li><a href="#event_connect_">Event: 'connect'</a></li><li><a href="#event_data_">Event: 'data'</a></li><li><a href="#event_end_">Event: 'end'</a></li><li><a href="#event_timeout_">Event: 'timeout'</a></li><li><a href="#event_drain_">Event: 'drain'</a></li><li><a href="#event_error_">Event: 'error'</a></li><li><a href="#event_close_">Event: 'close'</a></li></ul></li><li><a href="#net.isIP">net.isIP</a><ul><li><a href="#net.isIP">net.isIP(input)</a></li><li><a href="#net.isIPv4">net.isIPv4(input)</a></li><li><a href="#net.isIPv6">net.isIPv6(input)</a></li></ul></li></ul></li><li><a href="#uDP_Datagram_Sockets">UDP / Datagram Sockets</a><ul><li><a href="#event_message_">Event: 'message'</a></li><li><a href="#event_listening_">Event: 'listening'</a></li><li><a href="#event_close_">Event: 'close'</a></li><li><a href="#event_error_">Event: 'error'</a></li><li><a href="#dgram.createSocket">dgram.createSocket(type, [callback])</a></li><li><a href="#dgram.send">dgram.send(buf, offset, length, port, address, [callback])</a></li><li><a href="#dgram.bind">dgram.bind(port, [address])</a></li><li><a href="#dgram.close">dgram.close()</a></li><li><a href="#dgram.address">dgram.address()</a></li><li><a href="#dgram.setBroadcast">dgram.setBroadcast(flag)</a></li><li><a href="#dgram.setTTL">dgram.setTTL(ttl)</a></li><li><a href="#dgram.setMulticastTTL">dgram.setMulticastTTL(ttl)</a></li><li><a href="#dgram.setMulticastLoopback">dgram.setMulticastLoopback(flag)</a></li><li><a href="#dgram.addMembership">dgram.addMembership(multicastAddress, [multicastInterface])</a></li><li><a href="#dgram.dropMembership">dgram.dropMembership(multicastAddress, [multicastInterface])</a></li></ul></li><li><a href="#dNS">DNS</a><ul><li><a href="#dns.lookup">dns.lookup(domain, [family], callback)</a></li><li><a href="#dns.resolve">dns.resolve(domain, [rrtype], callback)</a></li><li><a href="#dns.resolve4">dns.resolve4(domain, callback)</a></li><li><a href="#dns.resolve6">dns.resolve6(domain, callback)</a></li><li><a href="#dns.resolveMx">dns.resolveMx(domain, callback)</a></li><li><a href="#dns.resolveTxt">dns.resolveTxt(domain, callback)</a></li><li><a href="#dns.resolveSrv">dns.resolveSrv(domain, callback)</a></li><li><a href="#dns.reverse">dns.reverse(ip, callback)</a></li><li><a href="#dns.resolveNs">dns.resolveNs(domain, callback)</a></li><li><a href="#dns.resolveCname">dns.resolveCname(domain, callback)</a></li></ul></li><li><a href="#hTTP">HTTP</a></li><li><a href="#http.Server">http.Server</a><ul><li><a href="#event_request_">Event: 'request'</a></li><li><a href="#event_connection_">Event: 'connection'</a></li><li><a href="#event_close_">Event: 'close'</a></li><li><a href="#event_checkContinue_">Event: 'checkContinue'</a></li><li><a href="#event_upgrade_">Event: 'upgrade'</a></li><li><a href="#event_clientError_">Event: 'clientError'</a></li><li><a href="#http.createServer">http.createServer([requestListener])</a></li><li><a href="#server.listen">server.listen(port, [hostname], [callback])</a></li><li><a href="#server.listen">server.listen(path, [callback])</a></li><li><a href="#server.close">server.close()</a></li></ul></li><li><a href="#http.ServerRequest">http.ServerRequest</a><ul><li><a href="#event_data_">Event: 'data'</a></li><li><a href="#event_end_">Event: 'end'</a></li><li><a href="#event_close_">Event: 'close'</a></li><li><a href="#request.method">request.method</a></li><li><a href="#request.url">request.url</a></li><li><a href="#request.headers">request.headers</a></li><li><a href="#request.trailers">request.trailers</a></li><li><a href="#request.httpVersion">request.httpVersion</a></li><li><a href="#request.setEncoding">request.setEncoding([encoding])</a></li><li><a href="#request.pause">request.pause()</a></li><li><a href="#request.resume">request.resume()</a></li><li><a href="#request.connection">request.connection</a></li></ul></li><li><a href="#http.ServerResponse">http.ServerResponse</a><ul><li><a href="#event_close_">Event: 'close'</a></li><li><a href="#response.writeContinue">response.writeContinue()</a></li><li><a href="#response.writeHead">response.writeHead(statusCode, [reasonPhrase], [headers])</a></li><li><a href="#response.statusCode">response.statusCode</a></li><li><a href="#response.setHeader">response.setHeader(name, value)</a></li><li><a href="#response.getHeader">response.getHeader(name)</a></li><li><a href="#response.removeHeader">response.removeHeader(name)</a></li><li><a href="#response.write">response.write(chunk, [encoding])</a></li><li><a href="#response.addTrailers">response.addTrailers(headers)</a></li><li><a href="#response.end">response.end([data], [encoding])</a></li></ul></li><li><a href="#http.request">http.request(options, callback)</a></li><li><a href="#http.get">http.get(options, callback)</a></li><li><a href="#http.Agent">http.Agent</a></li><li><a href="#http.globalAgent">http.globalAgent</a><ul><li><a href="#agent.maxSockets">agent.maxSockets</a></li><li><a href="#agent.sockets">agent.sockets</a></li><li><a href="#agent.requests">agent.requests</a></li></ul></li><li><a href="#http.ClientRequest">http.ClientRequest</a><ul><li><a href="#event_response_">Event 'response'</a></li><li><a href="#event_socket_">Event: 'socket'</a></li><li><a href="#event_upgrade_">Event: 'upgrade'</a></li><li><a href="#event_continue_">Event: 'continue'</a></li><li><a href="#request.write">request.write(chunk, [encoding])</a></li><li><a href="#request.end">request.end([data], [encoding])</a></li><li><a href="#request.abort">request.abort()</a></li><li><a href="#request.setTimeout">request.setTimeout(timeout, [callback])</a></li><li><a href="#request.setNoDelay">request.setNoDelay([noDelay])</a></li><li><a href="#request.setSocketKeepAlive">request.setSocketKeepAlive([enable], [initialDelay])</a></li></ul></li><li><a href="#http.ClientResponse">http.ClientResponse</a><ul><li><a href="#event_data_">Event: 'data'</a></li><li><a href="#event_end_">Event: 'end'</a></li><li><a href="#event_close_">Event: 'close'</a></li><li><a href="#response.statusCode">response.statusCode</a></li><li><a href="#response.httpVersion">response.httpVersion</a></li><li><a href="#response.headers">response.headers</a></li><li><a href="#response.trailers">response.trailers</a></li><li><a href="#response.setEncoding">response.setEncoding([encoding])</a></li><li><a href="#response.pause">response.pause()</a></li><li><a href="#response.resume">response.resume()</a></li></ul></li><li><a href="#hTTPS">HTTPS</a></li><li><a href="#https.Server">https.Server</a></li><li><a href="#https.createServer">https.createServer(options, [requestListener])</a></li><li><a href="#https.request">https.request(options, callback)</a></li><li><a href="#https.get">https.get(options, callback)</a></li><li><a href="#https.Agent">https.Agent</a></li><li><a href="#https.globalAgent">https.globalAgent</a></li><li><a href="#uRL">URL</a><ul><li><a href="#url.parse">url.parse(urlStr, [parseQueryString], [slashesDenoteHost])</a></li><li><a href="#url.format">url.format(urlObj)</a></li><li><a href="#url.resolve">url.resolve(from, to)</a></li></ul></li><li><a href="#query_String">Query String</a><ul><li><a href="#querystring.stringify">querystring.stringify(obj, [sep], [eq])</a></li><li><a href="#querystring.parse">querystring.parse(str, [sep], [eq])</a></li><li><a href="#querystring.escape">querystring.escape</a></li><li><a href="#querystring.unescape">querystring.unescape</a></li></ul></li><li><a href="#readline">Readline</a><ul><li><a href="#rl.createInterface">rl.createInterface(input, output, completer)</a></li><li><a href="#rl.setPrompt">rl.setPrompt(prompt, length)</a></li><li><a href="#rl.prompt">rl.prompt()</a></li><li><a href="#rl.question">rl.question(query, callback)</a></li><li><a href="#rl.close">rl.close()</a></li><li><a href="#rl.pause">rl.pause()</a></li><li><a href="#rl.resume">rl.resume()</a></li><li><a href="#rl.write">rl.write()</a></li><li><a href="#event_line_">Event: 'line'</a></li><li><a href="#event_close_">Event: 'close'</a></li></ul></li><li><a href="#rEPL">REPL</a><ul><li><a href="#repl.start">repl.start([prompt], [stream], [eval], [useGlobal], [ignoreUndefined])</a></li><li><a href="#rEPL_Features">REPL Features</a></li></ul></li><li><a href="#executing_JavaScript">Executing JavaScript</a><ul><li><a href="#vm.runInThisContext">vm.runInThisContext(code, [filename])</a></li><li><a href="#vm.runInNewContext">vm.runInNewContext(code, [sandbox], [filename])</a></li><li><a href="#vm.runInContext">vm.runInContext(code, context, [filename])</a></li><li><a href="#vm.createContext">vm.createContext([initSandbox])</a></li><li><a href="#vm.createScript">vm.createScript(code, [filename])</a></li><li><a href="#script.runInThisContext">script.runInThisContext()</a></li><li><a href="#script.runInNewContext">script.runInNewContext([sandbox])</a></li></ul></li><li><a href="#child_Processes">Child Processes</a><ul><li><a href="#event_exit_">Event:  'exit'</a></li><li><a href="#child.stdin">child.stdin</a></li><li><a href="#child.stdout">child.stdout</a></li><li><a href="#child.stderr">child.stderr</a></li><li><a href="#child.pid">child.pid</a></li><li><a href="#child_process.spawn">child_process.spawn(command, [args], [options])</a></li><li><a href="#child_process.exec">child_process.exec(command, [options], callback)</a></li><li><a href="#child_process.execFile">child_process.execFile(file, args, options, callback)</a></li><li><a href="#child_process.fork">child_process.fork(modulePath, arguments, options)</a></li><li><a href="#child.kill">child.kill([signal])</a></li></ul></li><li><a href="#assert">Assert</a><ul><li><a href="#assert.fail">assert.fail(actual, expected, message, operator)</a></li><li><a href="#assert_assert.ok">assert(value, message), assert.ok(value, [message])</a></li><li><a href="#assert.equal">assert.equal(actual, expected, [message])</a></li><li><a href="#assert.notEqual">assert.notEqual(actual, expected, [message])</a></li><li><a href="#assert.deepEqual">assert.deepEqual(actual, expected, [message])</a></li><li><a href="#assert.notDeepEqual">assert.notDeepEqual(actual, expected, [message])</a></li><li><a href="#assert.strictEqual">assert.strictEqual(actual, expected, [message])</a></li><li><a href="#assert.notStrictEqual">assert.notStrictEqual(actual, expected, [message])</a></li><li><a href="#assert.throws">assert.throws(block, [error], [message])</a></li><li><a href="#assert.doesNotThrow">assert.doesNotThrow(block, [error], [message])</a></li><li><a href="#assert.ifError">assert.ifError(value)</a></li></ul></li><li><a href="#tTY">TTY</a><ul><li><a href="#tty.isatty">tty.isatty(fd)</a></li><li><a href="#tty.setRawMode">tty.setRawMode(mode)</a></li><li><a href="#tty.setWindowSize">tty.setWindowSize(fd, row, col)</a></li><li><a href="#tty.getWindowSize">tty.getWindowSize(fd)</a></li></ul></li><li><a href="#zlib">Zlib</a><ul><li><a href="#examples">Examples</a></li><li><a href="#constants">Constants</a></li><li><a href="#zlib.createGzip">zlib.createGzip([options])</a></li><li><a href="#zlib.createGunzip">zlib.createGunzip([options])</a></li><li><a href="#zlib.createDeflate">zlib.createDeflate([options])</a></li><li><a href="#zlib.createInflate">zlib.createInflate([options])</a></li><li><a href="#zlib.createDeflateRaw">zlib.createDeflateRaw([options])</a></li><li><a href="#zlib.createInflateRaw">zlib.createInflateRaw([options])</a></li><li><a href="#zlib.createUnzip">zlib.createUnzip([options])</a></li><li><a href="#zlib.Gzip">zlib.Gzip</a></li><li><a href="#zlib.Gunzip">zlib.Gunzip</a></li><li><a href="#zlib.Deflate">zlib.Deflate</a></li><li><a href="#zlib.Inflate">zlib.Inflate</a></li><li><a href="#zlib.DeflateRaw">zlib.DeflateRaw</a></li><li><a href="#zlib.InflateRaw">zlib.InflateRaw</a></li><li><a href="#zlib.Unzip">zlib.Unzip</a></li></ul></li><li><a href="#convenience_Methods">Convenience Methods</a><ul><li><a href="#zlib.deflate">zlib.deflate(buf, callback)</a></li><li><a href="#zlib.deflateRaw">zlib.deflateRaw(buf, callback)</a></li><li><a href="#zlib.gzip">zlib.gzip(buf, callback)</a></li><li><a href="#zlib.gunzip">zlib.gunzip(buf, callback)</a></li><li><a href="#zlib.inflate">zlib.inflate(buf, callback)</a></li><li><a href="#zlib.inflateRaw">zlib.inflateRaw(buf, callback)</a></li><li><a href="#zlib.unzip">zlib.unzip(buf, callback)</a></li></ul></li><li><a href="#options">Options</a><ul><li><a href="#memory_Usage_Tuning">Memory Usage Tuning</a></li></ul></li><li><a href="#os_Module">os Module</a><ul><li><a href="#os.hostname">os.hostname()</a></li><li><a href="#os.type">os.type()</a></li><li><a href="#os.platform">os.platform()</a></li><li><a href="#os.arch">os.arch()</a></li><li><a href="#os.release">os.release()</a></li><li><a href="#os.uptime">os.uptime()</a></li><li><a href="#os.loadavg">os.loadavg()</a></li><li><a href="#os.totalmem">os.totalmem()</a></li><li><a href="#os.freemem">os.freemem()</a></li><li><a href="#os.cpus">os.cpus()</a></li><li><a href="#os.networkInterfaces">os.networkInterfaces()</a></li></ul></li><li><a href="#debugger">Debugger</a><ul><li><a href="#watchers">Watchers</a></li><li><a href="#commands_reference">Commands reference</a><ul><li><a href="#stepping">Stepping</a></li><li><a href="#breakpoints">Breakpoints</a></li><li><a href="#info">Info</a></li><li><a href="#execution_control">Execution control</a></li><li><a href="#various">Various</a></li></ul></li><li><a href="#advanced_Usage">Advanced Usage</a></li></ul></li><li><a href="#cluster">Cluster</a><ul><li><a href="#cluster.fork">cluster.fork()</a></li><li><a href="#cluster.isMaster">cluster.isMaster</a></li><li><a href="#cluster.isWorker">cluster.isWorker</a></li><li><a href="#event_death_">Event: 'death'</a></li></ul></li></ul></li><li><a href="#appendixes">Appendixes</a><ul><li><a href="#appendix_1_Third_Party_Modules">Appendix 1 - Third Party Modules</a></li></ul><hr /></div>
<h2 id="synopsis">Synopsis</h2>

<p>An example of a <a href="http.html">web server</a> written with Node which responds with 'Hello
World':</p>

<pre><code>var http = require('http');

http.createServer(function (request, response) {
  response.writeHead(200, {'Content-Type': 'text/plain'});
  response.end('Hello World\n');
}).listen(8124);

console.log('Server running at http://127.0.0.1:8124/');</code></pre>

<p>To run the server, put the code into a file called <code>example.js</code> and execute
it with the node program</p>

<pre><code>&gt; node example.js
Server running at http://127.0.0.1:8124/</code></pre>

<p>All of the examples in the documentation can be run similarly.</p>

<h2 id="global_Objects">Global Objects</h2>

<p>These objects are available in all modules. Some of these objects aren't
actually in the global scope but in the module scope - this will be noted.</p>

<h3 id="global">global <a href="#global">#</a></h3>

<p>The global namespace object.</p>

<p>In browsers, the top-level scope is the global scope. That means that in
browsers if you're in the global scope <code>var something</code> will define a global
variable. In Node this is different. The top-level scope is not the global
scope; <code>var something</code> inside a Node module will be local to that module.</p>

<h3 id="process">process <a href="#process">#</a></h3>

<p>The process object. See the <a href="process.html#process">process object</a> section.</p>

<h3 id="console">console <a href="#console">#</a></h3>

<p>Used to print to stdout and stderr. See the <a href="stdio.html">stdio</a> section.</p>

<h3 id="buffer">Buffer <a href="#buffer">#</a></h3>

<p>Used to handle binary data. See the <a href="buffers.html">buffers</a> section.</p>

<h3 id="require">require() <a href="#require">#</a></h3>

<p>To require modules. See the <a href="modules.html#modules">Modules</a> section.
<code>require</code> isn't actually a global but rather local to each module.</p>

<h3 id="require.resolve">require.resolve() <a href="#require.resolve">#</a></h3>

<p>Use the internal <code>require()</code> machinery to look up the location of a module,
but rather than loading the module, just return the resolved filename.</p>

<h3 id="require.cache">require.cache <a href="#require.cache">#</a></h3>

<p>Modules are cached in this object when they are required. By deleting a key
value from this object, the next <code>require</code> will reload the module.</p>

<h3 id="__filename">__filename <a href="#__filename">#</a></h3>

<p>The filename of the code being executed.  This is the resolved absolute path
of this code file.  For a main program this is not necessarily the same
filename used in the command line.  The value inside a module is the path
to that module file.</p>

<p>Example: running <code>node example.js</code> from <code>/Users/mjr</code></p>

<pre><code>console.log(__filename);
// /Users/mjr/example.js</code></pre>

<p><code>__filename</code> isn't actually a global but rather local to each module.</p>

<h3 id="__dirname">__dirname <a href="#__dirname">#</a></h3>

<p>The name of the directory that the currently executing script resides in.</p>

<p>Example: running <code>node example.js</code> from <code>/Users/mjr</code></p>

<pre><code>console.log(__dirname);
// /Users/mjr</code></pre>

<p><code>__dirname</code> isn't actually a global but rather local to each module.</p>

<h3 id="module">module <a href="#module">#</a></h3>

<p>A reference to the current module. In particular
<code>module.exports</code> is the same as the <code>exports</code> object. See <code>src/node.js</code>
for more information.
<code>module</code> isn't actually a global but rather local to each module.</p>

<h3 id="exports">exports <a href="#exports">#</a></h3>

<p>An object which is shared between all instances of the current module and
made accessible through <code>require()</code>.
<code>exports</code> is the same as the <code>module.exports</code> object. See <code>src/node.js</code>
for more information.
<code>exports</code> isn't actually a global but rather local to each module.</p>

<h3 id="setTimeout">setTimeout(cb, ms) <a href="#setTimeout">#</a></h3>

<h3 id="clearTimeout">clearTimeout(t) <a href="#clearTimeout">#</a></h3>

<h3 id="setInterval">setInterval(cb, ms) <a href="#setInterval">#</a></h3>

<h3 id="clearInterval">clearInterval(t) <a href="#clearInterval">#</a></h3>

<p>The timer functions are global variables. See the <a href="timers.html">timers</a> section.</p>

<h2 id="console">console</h2>

<p>For printing to stdout and stderr.  Similar to the console object functions
provided by most web browsers, here the output is sent to stdout or stderr.</p>

<h3 id="console.log">console.log() <a href="#console.log">#</a></h3>

<p>Prints to stdout with newline. This function can take multiple arguments in a
<code>printf()</code>-like way. Example:</p>

<pre><code>console.log('count: %d', count);</code></pre>

<p>If formatting elements are not found in the first string then <code>util.inspect</code>
is used on each argument.
See <a href="util.html#util.format">util.format()</a> for more information.</p>

<h3 id="console.info">console.info() <a href="#console.info">#</a></h3>

<p>Same as <code>console.log</code>.</p>

<h3 id="console.warn">console.warn() <a href="#console.warn">#</a></h3>

<h3 id="console.error">console.error() <a href="#console.error">#</a></h3>

<p>Same as <code>console.log</code> but prints to stderr.</p>

<h3 id="console.dir">console.dir(obj) <a href="#console.dir">#</a></h3>

<p>Uses <code>util.inspect</code> on <code>obj</code> and prints resulting string to stderr.</p>

<h3 id="console.time">console.time(label) <a href="#console.time">#</a></h3>

<p>Mark a time.</p>

<h3 id="console.timeEnd">console.timeEnd(label) <a href="#console.timeEnd">#</a></h3>

<p>Finish timer, record output. Example</p>

<pre><code>console.time('100-elements');
for (var i = 0; i &lt; 100; i++) {
  ;
}
console.timeEnd('100-elements');</code></pre>

<h3 id="console.trace">console.trace() <a href="#console.trace">#</a></h3>

<p>Print a stack trace to stderr of the current position.</p>

<h3 id="console.assert">console.assert() <a href="#console.assert">#</a></h3>

<p>Same as <code>assert.ok()</code>.</p>

<h2 id="timers">Timers</h2>

<h3 id="setTimeout">setTimeout(callback, delay, [arg], [...]) <a href="#setTimeout">#</a></h3>

<p>To schedule execution of a one-time <code>callback</code> after <code>delay</code> milliseconds. Returns a
<code>timeoutId</code> for possible use with <code>clearTimeout()</code>. Optionally you can
also pass arguments to the callback.</p>

<p>It is important to note that your callback will probably not be called in exactly
<code>delay</code> milliseconds - Node.js makes no guarantees about the exact timing of when
the callback will fire, nor of the ordering things will fire in. The callback will
be called as close as possible to the time specified.</p>

<h3 id="clearTimeout">clearTimeout(timeoutId) <a href="#clearTimeout">#</a></h3>

<p>Prevents a timeout from triggering.</p>

<h3 id="setInterval">setInterval(callback, delay, [arg], [...]) <a href="#setInterval">#</a></h3>

<p>To schedule the repeated execution of <code>callback</code> every <code>delay</code> milliseconds.
Returns a <code>intervalId</code> for possible use with <code>clearInterval()</code>. Optionally
you can also pass arguments to the callback.</p>

<h3 id="clearInterval">clearInterval(intervalId) <a href="#clearInterval">#</a></h3>

<p>Stops a interval from triggering.</p>

<h2 id="modules">Modules</h2>

<p>Node has a simple module loading system.  In Node, files and modules are in
one-to-one correspondence.  As an example, <code>foo.js</code> loads the module
<code>circle.js</code> in the same directory.</p>

<p>The contents of <code>foo.js</code>:</p>

<pre><code>var circle = require('./circle.js');
console.log( 'The area of a circle of radius 4 is '
           + circle.area(4));</code></pre>

<p>The contents of <code>circle.js</code>:</p>

<pre><code>var PI = Math.PI;

exports.area = function (r) {
  return PI * r * r;
};

exports.circumference = function (r) {
  return 2 * PI * r;
};</code></pre>

<p>The module <code>circle.js</code> has exported the functions <code>area()</code> and
<code>circumference()</code>.  To export an object, add to the special <code>exports</code>
object.</p>

<p>Variables
local to the module will be private. In this example the variable <code>PI</code> is
private to <code>circle.js</code>.</p>

<h3 id="cycles">Cycles <a href="#cycles">#</a></h3>

<p>When there are circular <code>require()</code> calls, a module might not be
done being executed when it is returned.</p>

<p>Consider this situation:</p>

<p><code>a.js</code>:</p>

<pre><code>console.log('a starting');
exports.done = false;
var b = require('./b.js');
console.log('in a, b.done = %j', b.done);
exports.done = true;
console.log('a done');</code></pre>

<p><code>b.js</code>:</p>

<pre><code>console.log('b starting');
exports.done = false;
var a = require('./a.js');
console.log('in b, a.done = %j', a.done);
exports.done = true;
console.log('b done');</code></pre>

<p><code>main.js</code>:</p>

<pre><code>console.log('main starting');
var a = require('./a.js');
var b = require('./b.js');
console.log('in main, a.done=%j, b.done=%j', a.done, b.done);</code></pre>

<p>When <code>main.js</code> loads <code>a.js</code>, then <code>a.js</code> in turn loads <code>b.js</code>.  At that
point, <code>b.js</code> tries to load <code>a.js</code>.  In order to prevent an infinite
loop an <strong>unfinished copy</strong> of the <code>a.js</code> exports object is returned to the
<code>b.js</code> module.  <code>b.js</code> then finishes loading, and its exports object is
provided to the <code>a.js</code> module.</p>

<p>By the time <code>main.js</code> has loaded both modules, they're both finished.
The output of this program would thus be:</p>

<pre><code>$ node main.js
main starting
a starting
b starting
in b, a.done = false
b done
in a, b.done = true
a done
in main, a.done=true, b.done=true</code></pre>

<p>If you have cyclic module dependencies in your program, make sure to
plan accordingly.</p>

<h3 id="core_Modules">Core Modules <a href="#core_Modules">#</a></h3>

<p>Node has several modules compiled into the binary.  These modules are
described in greater detail elsewhere in this documentation.</p>

<p>The core modules are defined in node's source in the <code>lib/</code> folder.</p>

<p>Core modules are always preferentially loaded if their identifier is
passed to <code>require()</code>.  For instance, <code>require('http')</code> will always
return the built in HTTP module, even if there is a file by that name.</p>

<h3 id="file_Modules">File Modules <a href="#file_Modules">#</a></h3>

<p>If the exact filename is not found, then node will attempt to load the
required filename with the added extension of <code>.js</code>, <code>.json</code>, and then <code>.node</code>.</p>

<p><code>.js</code> files are interpreted as JavaScript text files, and <code>.json</code> files are
parsed as JSON text files. <code>.node</code> files are interpreted as compiled addon
modules loaded with <code>dlopen</code>.</p>

<p>A module prefixed with <code>'/'</code> is an absolute path to the file.  For
example, <code>require('/home/marco/foo.js')</code> will load the file at
<code>/home/marco/foo.js</code>.</p>

<p>A module prefixed with <code>'./'</code> is relative to the file calling <code>require()</code>.
That is, <code>circle.js</code> must be in the same directory as <code>foo.js</code> for
<code>require('./circle')</code> to find it.</p>

<p>Without a leading '/' or './' to indicate a file, the module is either a
"core module" or is loaded from a <code>node_modules</code> folder.</p>

<h3 id="loading_from_node_modules_Folders">Loading from `node_modules` Folders <a href="#loading_from_node_modules_Folders">#</a></h3>

<p>If the module identifier passed to <code>require()</code> is not a native module,
and does not begin with <code>'/'</code>, <code>'../'</code>, or <code>'./'</code>, then node starts at the
parent directory of the current module, and adds <code>/node_modules</code>, and
attempts to load the module from that location.</p>

<p>If it is not found there, then it moves to the parent directory, and so
on, until the root of the tree is reached.</p>

<p>For example, if the file at <code>'/home/ry/projects/foo.js'</code> called
<code>require('bar.js')</code>, then node would look in the following locations, in
this order:</p>

<ul><li><code>/home/ry/projects/node_modules/bar.js</code></li><li><code>/home/ry/node_modules/bar.js</code></li><li><code>/home/node_modules/bar.js</code></li><li><code>/node_modules/bar.js</code></li></ul>

<p>This allows programs to localize their dependencies, so that they do not
clash.</p>

<h3 id="folders_as_Modules">Folders as Modules <a href="#folders_as_Modules">#</a></h3>

<p>It is convenient to organize programs and libraries into self-contained
directories, and then provide a single entry point to that library.
There are three ways in which a folder may be passed to <code>require()</code> as
an argument.</p>

<p>The first is to create a <code>package.json</code> file in the root of the folder,
which specifies a <code>main</code> module.  An example package.json file might
look like this:</p>

<pre><code>{ "name" : "some-library",
  "main" : "./lib/some-library.js" }</code></pre>

<p>If this was in a folder at <code>./some-library</code>, then
<code>require('./some-library')</code> would attempt to load
<code>./some-library/lib/some-library.js</code>.</p>

<p>This is the extent of Node's awareness of package.json files.</p>

<p>If there is no package.json file present in the directory, then node
will attempt to load an <code>index.js</code> or <code>index.node</code> file out of that
directory.  For example, if there was no package.json file in the above
example, then <code>require('./some-library')</code> would attempt to load:</p>

<ul><li><code>./some-library/index.js</code></li><li><code>./some-library/index.node</code></li></ul>

<h3 id="caching">Caching <a href="#caching">#</a></h3>

<p>Modules are cached after the first time they are loaded.  This means
(among other things) that every call to <code>require('foo')</code> will get
exactly the same object returned, if it would resolve to the same file.</p>

<p>Multiple calls to <code>require('foo')</code> may not cause the module code to be
executed multiple times.  This is an important feature.  With it,
"partially done" objects can be returned, thus allowing transitive
dependencies to be loaded even when they would cause cycles.</p>

<p>If you want to have a module execute code multiple times, then export a
function, and call that function.</p>

<h4 id="module_Caching_Caveats">Module Caching Caveats <a href="#module_Caching_Caveats">#</a></h4>

<p>Modules are cached based on their resolved filename.  Since modules may
resolve to a different filename based on the location of the calling
module (loading from <code>node_modules</code> folders), it is not a <em>guarantee</em>
that <code>require('foo')</code> will always return the exact same object, if it
would resolve to different files.</p>

<h3 id="module.exports">module.exports <a href="#module.exports">#</a></h3>

<p>The <code>exports</code> object is created by the Module system. Sometimes this is not
acceptable, many want their module to be an instance of some class. To do this
assign the desired export object to <code>module.exports</code>. For example suppose we
were making a module called <code>a.js</code></p>

<pre><code>var EventEmitter = require('events').EventEmitter;

module.exports = new EventEmitter();

// Do some work, and after some time emit
// the 'ready' event from the module itself.
setTimeout(function() {
  module.exports.emit('ready');
}, 1000);</code></pre>

<p>Then in another file we could do</p>

<pre><code>var a = require('./a');
a.on('ready', function() {
  console.log('module a is ready');
});</code></pre>

<p>Note that assignment to <code>module.exports</code> must be done immediately. It cannot be
done in any callbacks.  This does not work:</p>

<p>x.js:</p>

<pre><code>setTimeout(function() {
  module.exports = { a: "hello" };
}, 0);</code></pre>

<p>y.js:</p>

<pre><code>var x = require('./x');
console.log(x.a);</code></pre>

<h3 id="module.require">module.require <a href="#module.require">#</a></h3>

<p>The <code>module.require</code> method provides a way to load a module as if
<code>require()</code> was called from the original module.</p>

<p>Note that in order to do this, you must get a reference to the <code>module</code>
object.  Since <code>require()</code> returns the <code>exports</code>, and the <code>module</code> is
typically <em>only</em> available within a specific module's code, it must be
explicitly exported in order to be used.</p>

<h3 id="all_Together...">All Together... <a href="#all_Together...">#</a></h3>

<p>To get the exact filename that will be loaded when <code>require()</code> is called, use
the <code>require.resolve()</code> function.</p>

<p>Putting together all of the above, here is the high-level algorithm
in pseudocode of what require.resolve does:</p>

<pre><code>require(X) from module at path Y
1. If X is a core module,
   a. return the core module
   b. STOP
2. If X begins with './' or '/' or '../'
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
3. LOAD_NODE_MODULES(X, dirname(Y))
4. THROW "not found"

LOAD_AS_FILE(X)
1. If X is a file, load X as JavaScript text.  STOP
2. If X.js is a file, load X.js as JavaScript text.  STOP
3. If X.node is a file, load X.node as binary addon.  STOP

LOAD_AS_DIRECTORY(X)
1. If X/package.json is a file,
   a. Parse X/package.json, and look for "main" field.
   b. let M = X + (json main field)
   c. LOAD_AS_FILE(M)
2. If X/index.js is a file, load X/index.js as JavaScript text.  STOP
3. If X/index.node is a file, load X/index.node as binary addon.  STOP

LOAD_NODE_MODULES(X, START)
1. let DIRS=NODE_MODULES_PATHS(START)
2. for each DIR in DIRS:
   a. LOAD_AS_FILE(DIR/X)
   b. LOAD_AS_DIRECTORY(DIR/X)

NODE_MODULES_PATHS(START)
1. let PARTS = path split(START)
2. let ROOT = index of first instance of "node_modules" in PARTS, or 0
3. let I = count of PARTS - 1
4. let DIRS = []
5. while I &gt; ROOT,
   a. if PARTS[I] = "node_modules" CONTINUE
   c. DIR = path join(PARTS[0 .. I] + "node_modules")
   b. DIRS = DIRS + DIR
   c. let I = I - 1
6. return DIRS</code></pre>

<h3 id="loading_from_the_global_folders">Loading from the global folders <a href="#loading_from_the_global_folders">#</a></h3>

<p>If the <code>NODE_PATH</code> environment variable is set to a colon-delimited list
of absolute paths, then node will search those paths for modules if they
are not found elsewhere.  (Note: On Windows, <code>NODE_PATH</code> is delimited by
semicolons instead of colons.)</p>

<p>Additionally, node will search in the following locations:</p>

<ul><li>1: <code>$HOME/.node_modules</code></li><li>2: <code>$HOME/.node_libraries</code></li><li>3: <code>$PREFIX/lib/node</code></li></ul>

<p>Where <code>$HOME</code> is the user's home directory, and <code>$PREFIX</code> is node's
configured <code>installPrefix</code>.</p>

<p>These are mostly for historic reasons.  You are highly encouraged to
place your dependencies locally in <code>node_modules</code> folders.  They will be
loaded faster, and more reliably.</p>

<h3 id="accessing_the_main_module">Accessing the main module <a href="#accessing_the_main_module">#</a></h3>

<p>When a file is run directly from Node, <code>require.main</code> is set to its
<code>module</code>. That means that you can determine whether a file has been run
directly by testing</p>

<pre><code>require.main === module</code></pre>

<p>For a file <code>foo.js</code>, this will be <code>true</code> if run via <code>node foo.js</code>, but
<code>false</code> if run by <code>require('./foo')</code>.</p>

<p>Because <code>module</code> provides a <code>filename</code> property (normally equivalent to
<code>__filename</code>), the entry point of the current application can be obtained
by checking <code>require.main.filename</code>.</p>

<h2 id="addenda_Package_Manager_Tips">Addenda: Package Manager Tips</h2>

<p>The semantics of Node's <code>require()</code> function were designed to be general
enough to support a number of sane directory structures. Package manager
programs such as <code>dpkg</code>, <code>rpm</code>, and <code>npm</code> will hopefully find it possible to
build native packages from Node modules without modification.</p>

<p>Below we give a suggested directory structure that could work:</p>

<p>Let's say that we wanted to have the folder at
<code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code> hold the contents of a
specific version of a package.</p>

<p>Packages can depend on one another. In order to install package <code>foo</code>, you
may have to install a specific version of package <code>bar</code>.  The <code>bar</code> package
may itself have dependencies, and in some cases, these dependencies may even
collide or form cycles.</p>

<p>Since Node looks up the <code>realpath</code> of any modules it loads (that is,
resolves symlinks), and then looks for their dependencies in the
<code>node_modules</code> folders as described above, this situation is very simple to
resolve with the following architecture:</p>

<ul><li><code>/usr/lib/node/foo/1.2.3/</code> - Contents of the <code>foo</code> package, version 1.2.3.</li><li><code>/usr/lib/node/bar/4.3.2/</code> - Contents of the <code>bar</code> package that <code>foo</code>
depends on.</li><li><code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> - Symbolic link to
<code>/usr/lib/node/bar/4.3.2/</code>.</li><li><code>/usr/lib/node/bar/4.3.2/node_modules/*</code> - Symbolic links to the packages
that <code>bar</code> depends on.</li></ul>

<p>Thus, even if a cycle is encountered, or if there are dependency
conflicts, every module will be able to get a version of its dependency
that it can use.</p>

<p>When the code in the <code>foo</code> package does <code>require('bar')</code>, it will get the
version that is symlinked into <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code>.
Then, when the code in the <code>bar</code> package calls <code>require('quux')</code>, it'll get
the version that is symlinked into
<code>/usr/lib/node/bar/4.3.2/node_modules/quux</code>.</p>

<p>Furthermore, to make the module lookup process even more optimal, rather
than putting packages directly in <code>/usr/lib/node</code>, we could put them in
<code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code>.  Then node will not bother
looking for missing dependencies in <code>/usr/node_modules</code> or <code>/node_modules</code>.</p>

<p>In order to make modules available to the node REPL, it might be useful to
also add the <code>/usr/lib/node_modules</code> folder to the <code>$NODE_PATH</code> environment
variable.  Since the module lookups using <code>node_modules</code> folders are all
relative, and based on the real path of the files making the calls to
<code>require()</code>, the packages themselves can be anywhere.</p>

<h2 id="addons">Addons</h2>

<p>Addons are dynamically linked shared objects. They can provide glue to C and
C++ libraries. The API (at the moment) is rather complex, involving
knowledge of several libraries:</p>

<ul><li><p>V8 JavaScript, a C++ library. Used for interfacing with JavaScript:
creating objects, calling functions, etc.  Documented mostly in the
<code>v8.h</code> header file (<code>deps/v8/include/v8.h</code> in the Node source tree).</p></li><li><p><a href="https://github.com/joyent/libuv">libuv</a>, C event loop library. Anytime one
needs to wait for a file descriptor to become readable, wait for a timer, or
wait for a signal to received one will need to interface with libuv. That is,
if you perform any I/O, libuv will need to be used.</p></li><li><p>Internal Node libraries. Most importantly is the <code>node::ObjectWrap</code>
class which you will likely want to derive from.</p></li><li><p>Others. Look in <code>deps/</code> for what else is available.</p></li></ul>

<p>Node statically compiles all its dependencies into the executable. When
compiling your module, you don't need to worry about linking to any of these
libraries.</p>

<p>To get started let's make a small Addon which is the C++ equivalent of
the following Javascript code:</p>

<pre><code>exports.hello = function() { return 'world'; };</code></pre>

<p>To get started we create a file <code>hello.cc</code>:</p>

<pre><code>#include &lt;node.h&gt;
#include &lt;v8.h&gt;

using namespace v8;

Handle&lt;Value&gt; Method(const Arguments&amp; args) {
  HandleScope scope;
  return scope.Close(String::New("world"));
}

void init(Handle&lt;Object&gt; target) {
  NODE_SET_METHOD(target, "hello", Method);
}
NODE_MODULE(hello, init)</code></pre>

<p>Note that all Node addons must export an initialization function:</p>

<pre><code>void Initialize (Handle&lt;Object&gt; target);
NODE_MODULE(module_name, Initialize)</code></pre>

<p>There is no semi-colon after <code>NODE_MODULE</code> as it's not a function (see <code>node.h</code>).</p>

<p>The <code>module_name</code> needs to match the filename of the final binary (minus the
.node suffix).</p>

<p>The source code needs to be built into <code>hello.node</code>, the binary Addon. To
do this we create a file called <code>wscript</code> which is python code and looks
like this:</p>

<pre><code>srcdir = '.'
blddir = 'build'
VERSION = '0.0.1'

def set_options(opt):
  opt.tool_options('compiler_cxx')

def configure(conf):
  conf.check_tool('compiler_cxx')
  conf.check_tool('node_addon')

def build(bld):
  obj = bld.new_task_gen('cxx', 'shlib', 'node_addon')
  obj.target = 'hello'
  obj.source = 'hello.cc'</code></pre>

<p>Running <code>node-waf configure build</code> will create a file
<code>build/default/hello.node</code> which is our Addon.</p>

<p><code>node-waf</code> is just <a href="http://code.google.com/p/waf">WAF</a>, the python-based build system. <code>node-waf</code> is
provided for the ease of users.</p>

<p>You can now use the binary addon in a Node project <code>hello.js</code> by pointing <code>require</code> to
the recently built module:</p>

<pre><code>var addon = require('./build/Release/hello');

console.log(addon.hello()); // 'world'</code></pre>

<p>For the moment, that is all the documentation on addons. Please see
<a href="https://github.com/pietern/hiredis-node">https://github.com/pietern/hiredis-node</a> for a real example.</p>

<h2 id="process">process</h2>

<p>The <code>process</code> object is a global object and can be accessed from anywhere.
It is an instance of <code>EventEmitter</code>.</p>

<h3 id="event_exit_">Event: 'exit' <a href="#event_exit_">#</a></h3>

<p><code>function () {}</code></p>

<p>Emitted when the process is about to exit.  This is a good hook to perform
constant time checks of the module's state (like for unit tests).  The main
event loop will no longer be run after the 'exit' callback finishes, so
timers may not be scheduled.</p>

<p>Example of listening for <code>exit</code>:</p>

<pre><code>process.on('exit', function () {
  process.nextTick(function () {
   console.log('This will not run');
  });
  console.log('About to exit.');
});</code></pre>

<h3 id="event_uncaughtException_">Event: 'uncaughtException' <a href="#event_uncaughtException_">#</a></h3>

<p><code>function (err) { }</code></p>

<p>Emitted when an exception bubbles all the way back to the event loop. If a
listener is added for this exception, the default action (which is to print
a stack trace and exit) will not occur.</p>

<p>Example of listening for <code>uncaughtException</code>:</p>

<pre><code>process.on('uncaughtException', function (err) {
  console.log('Caught exception: ' + err);
});

setTimeout(function () {
  console.log('This will still run.');
}, 500);

// Intentionally cause an exception, but don't catch it.
nonexistentFunc();
console.log('This will not run.');</code></pre>

<p>Note that <code>uncaughtException</code> is a very crude mechanism for exception
handling.  Using try / catch in your program will give you more control over
your program's flow.  Especially for server programs that are designed to
stay running forever, <code>uncaughtException</code> can be a useful safety mechanism.</p>

<h3 id="signal_Events">Signal Events <a href="#signal_Events">#</a></h3>

<p><code>function () {}</code></p>

<p>Emitted when the processes receives a signal. See sigaction(2) for a list of
standard POSIX signal names such as SIGINT, SIGUSR1, etc.</p>

<p>Example of listening for <code>SIGINT</code>:</p>

<pre><code>// Start reading from stdin so we don't exit.
process.stdin.resume();

process.on('SIGINT', function () {
  console.log('Got SIGINT.  Press Control-D to exit.');
});</code></pre>

<p>An easy way to send the <code>SIGINT</code> signal is with <code>Control-C</code> in most terminal
programs.</p>

<h3 id="process.stdout">process.stdout <a href="#process.stdout">#</a></h3>

<p>A <code>Writable Stream</code> to <code>stdout</code>.</p>

<p>Example: the definition of <code>console.log</code></p>

<pre><code>console.log = function (d) {
  process.stdout.write(d + '\n');
};</code></pre>

<p><code>process.stderr</code> and <code>process.stdout</code> are unlike other streams in Node in
that writes to them are usually blocking.  They are blocking in the case
that they refer to regular files or TTY file descriptors. In the case they
refer to pipes, they are non-blocking like other streams.</p>

<h3 id="process.stderr">process.stderr <a href="#process.stderr">#</a></h3>

<p>A writable stream to stderr.</p>

<p><code>process.stderr</code> and <code>process.stdout</code> are unlike other streams in Node in
that writes to them are usually blocking.  They are blocking in the case
that they refer to regular files or TTY file descriptors. In the case they
refer to pipes, they are non-blocking like other streams.</p>

<h3 id="process.stdin">process.stdin <a href="#process.stdin">#</a></h3>

<p>A <code>Readable Stream</code> for stdin. The stdin stream is paused by default, so one
must call <code>process.stdin.resume()</code> to read from it.</p>

<p>Example of opening standard input and listening for both events:</p>

<pre><code>process.stdin.resume();
process.stdin.setEncoding('utf8');

process.stdin.on('data', function (chunk) {
  process.stdout.write('data: ' + chunk);
});

process.stdin.on('end', function () {
  process.stdout.write('end');
});</code></pre>

<h3 id="process.argv">process.argv <a href="#process.argv">#</a></h3>

<p>An array containing the command line arguments.  The first element will be
'node', the second element will be the name of the JavaScript file.  The
next elements will be any additional command line arguments.</p>

<pre><code>// print process.argv
process.argv.forEach(function (val, index, array) {
  console.log(index + ': ' + val);
});</code></pre>

<p>This will generate:</p>

<pre><code>$ node process-2.js one two=three four
0: node
1: /Users/mjr/work/node/process-2.js
2: one
3: two=three
4: four</code></pre>

<h3 id="process.execPath">process.execPath <a href="#process.execPath">#</a></h3>

<p>This is the absolute pathname of the executable that started the process.</p>

<p>Example:</p>

<pre><code>/usr/local/bin/node</code></pre>

<h3 id="process.chdir">process.chdir(directory) <a href="#process.chdir">#</a></h3>

<p>Changes the current working directory of the process or throws an exception if that fails.</p>

<pre><code>console.log('Starting directory: ' + process.cwd());
try {
  process.chdir('/tmp');
  console.log('New directory: ' + process.cwd());
}
catch (err) {
  console.log('chdir: ' + err);
}</code></pre>

<h3 id="process.cwd">process.cwd() <a href="#process.cwd">#</a></h3>

<p>Returns the current working directory of the process.</p>

<pre><code>console.log('Current directory: ' + process.cwd());</code></pre>

<h3 id="process.env">process.env <a href="#process.env">#</a></h3>

<p>An object containing the user environment. See environ(7).</p>

<h3 id="process.exit">process.exit([code]) <a href="#process.exit">#</a></h3>

<p>Ends the process with the specified <code>code</code>.  If omitted, exit uses the
'success' code <code>0</code>.</p>

<p>To exit with a 'failure' code:</p>

<pre><code>process.exit(1);</code></pre>

<p>The shell that executed node should see the exit code as 1.</p>

<h3 id="process.getgid">process.getgid() <a href="#process.getgid">#</a></h3>

<p>Gets the group identity of the process. (See getgid(2).)
This is the numerical group id, not the group name.</p>

<pre><code>console.log('Current gid: ' + process.getgid());</code></pre>

<h3 id="process.setgid">process.setgid(id) <a href="#process.setgid">#</a></h3>

<p>Sets the group identity of the process. (See setgid(2).)  This accepts either
a numerical ID or a groupname string. If a groupname is specified, this method
blocks while resolving it to a numerical ID.</p>

<pre><code>console.log('Current gid: ' + process.getgid());
try {
  process.setgid(501);
  console.log('New gid: ' + process.getgid());
}
catch (err) {
  console.log('Failed to set gid: ' + err);
}</code></pre>

<h3 id="process.getuid">process.getuid() <a href="#process.getuid">#</a></h3>

<p>Gets the user identity of the process. (See getuid(2).)
This is the numerical userid, not the username.</p>

<pre><code>console.log('Current uid: ' + process.getuid());</code></pre>

<h3 id="process.setuid">process.setuid(id) <a href="#process.setuid">#</a></h3>

<p>Sets the user identity of the process. (See setuid(2).)  This accepts either
a numerical ID or a username string.  If a username is specified, this method
blocks while resolving it to a numerical ID.</p>

<pre><code>console.log('Current uid: ' + process.getuid());
try {
  process.setuid(501);
  console.log('New uid: ' + process.getuid());
}
catch (err) {
  console.log('Failed to set uid: ' + err);
}</code></pre>

<h3 id="process.version">process.version <a href="#process.version">#</a></h3>

<p>A compiled-in property that exposes <code>NODE_VERSION</code>.</p>

<pre><code>console.log('Version: ' + process.version);</code></pre>

<h3 id="process.versions">process.versions <a href="#process.versions">#</a></h3>

<p>A property exposing version strings of node and its dependencies.</p>

<pre><code>console.log(process.versions);</code></pre>

<p>Will output:</p>

<pre><code>{ node: '0.4.12',
  v8: '3.1.8.26',
  ares: '1.7.4',
  ev: '4.4',
  openssl: '1.0.0e-fips' }</code></pre>

<h3 id="process.installPrefix">process.installPrefix <a href="#process.installPrefix">#</a></h3>

<p>A compiled-in property that exposes <code>NODE_PREFIX</code>.</p>

<pre><code>console.log('Prefix: ' + process.installPrefix);</code></pre>

<h3 id="process.kill">process.kill(pid, [signal]) <a href="#process.kill">#</a></h3>

<p>Send a signal to a process. <code>pid</code> is the process id and <code>signal</code> is the
string describing the signal to send.  Signal names are strings like
'SIGINT' or 'SIGUSR1'.  If omitted, the signal will be 'SIGTERM'.
See kill(2) for more information.</p>

<p>Note that just because the name of this function is <code>process.kill</code>, it is
really just a signal sender, like the <code>kill</code> system call.  The signal sent
may do something other than kill the target process.</p>

<p>Example of sending a signal to yourself:</p>

<pre><code>process.on('SIGHUP', function () {
  console.log('Got SIGHUP signal.');
});

setTimeout(function () {
  console.log('Exiting.');
  process.exit(0);
}, 100);

process.kill(process.pid, 'SIGHUP');</code></pre>

<h3 id="process.pid">process.pid <a href="#process.pid">#</a></h3>

<p>The PID of the process.</p>

<pre><code>console.log('This process is pid ' + process.pid);</code></pre>

<h3 id="process.title">process.title <a href="#process.title">#</a></h3>

<p>Getter/setter to set what is displayed in 'ps'.</p>

<h3 id="process.arch">process.arch <a href="#process.arch">#</a></h3>

<p>What processor architecture you're running on: <code>'arm'</code>, <code>'ia32'</code>, or <code>'x64'</code>.</p>

<pre><code>console.log('This processor architecture is ' + process.arch);</code></pre>

<h3 id="process.platform">process.platform <a href="#process.platform">#</a></h3>

<p>What platform you're running on. <code>'linux2'</code>, <code>'darwin'</code>, etc.</p>

<pre><code>console.log('This platform is ' + process.platform);</code></pre>

<h3 id="process.memoryUsage">process.memoryUsage() <a href="#process.memoryUsage">#</a></h3>

<p>Returns an object describing the memory usage of the Node process
measured in bytes.</p>

<pre><code>var util = require('util');

console.log(util.inspect(process.memoryUsage()));</code></pre>

<p>This will generate:</p>

<pre><code>{ rss: 4935680,
  heapTotal: 1826816,
  heapUsed: 650472 }</code></pre>

<p><code>heapTotal</code> and <code>heapUsed</code> refer to V8's memory usage.</p>

<h3 id="process.nextTick">process.nextTick(callback) <a href="#process.nextTick">#</a></h3>

<p>On the next loop around the event loop call this callback.
This is <em>not</em> a simple alias to <code>setTimeout(fn, 0)</code>, it's much more
efficient.</p>

<pre><code>process.nextTick(function () {
  console.log('nextTick callback');
});</code></pre>

<h3 id="process.umask">process.umask([mask]) <a href="#process.umask">#</a></h3>

<p>Sets or reads the process's file mode creation mask. Child processes inherit
the mask from the parent process. Returns the old mask if <code>mask</code> argument is
given, otherwise returns the current mask.</p>

<pre><code>var oldmask, newmask = 0644;

oldmask = process.umask(newmask);
console.log('Changed umask from: ' + oldmask.toString(8) +
            ' to ' + newmask.toString(8));</code></pre>

<h3 id="process.uptime">process.uptime() <a href="#process.uptime">#</a></h3>

<p>Number of seconds Node has been running.</p>

<h2 id="util">util</h2>

<p>These functions are in the module <code>'util'</code>. Use <code>require('util')</code> to access
them.</p>

<h3 id="util.format">util.format() <a href="#util.format">#</a></h3>

<p>Returns a formatted string using the first argument as a <code>printf</code>-like format.</p>

<p>The first argument is a string that contains zero or more <em>placeholders</em>.
Each placeholder is replaced with the converted value from its corresponding
argument. Supported placeholders are:</p>

<ul><li><code>%s</code> - String.</li><li><code>%d</code> - Number (both integer and float).</li><li><code>%j</code> - JSON.</li><li><code>%%</code> - single percent sign (<code>'%'</code>). This does not consume an argument.</li></ul>

<p>If the placeholder does not have a corresponding argument, the placeholder is
not replaced.</p>

<pre><code>util.format('%s:%s', 'foo'); // 'foo:%s'</code></pre>

<p>If there are more arguments than placeholders, the extra arguments are
converted to strings with <code>util.inspect()</code> and these strings are concatenated,
delimited by a space.</p>

<pre><code>util.format('%s:%s', 'foo', 'bar', 'baz'); // 'foo:bar baz'</code></pre>

<p>If the first argument is not a format string then <code>util.format()</code> returns
a string that is the concatenation of all its arguments separated by spaces.
Each argument is converted to a string with <code>util.inspect()</code>.</p>

<pre><code>util.format(1, 2, 3); // '1 2 3'</code></pre>

<h3 id="util.debug">util.debug(string) <a href="#util.debug">#</a></h3>

<p>A synchronous output function. Will block the process and
output <code>string</code> immediately to <code>stderr</code>.</p>

<pre><code>require('util').debug('message on stderr');</code></pre>

<h3 id="util.log">util.log(string) <a href="#util.log">#</a></h3>

<p>Output with timestamp on <code>stdout</code>.</p>

<pre><code>require('util').log('Timestamped message.');</code></pre>

<h3 id="util.inspect">util.inspect(object, [showHidden], [depth], [colors]) <a href="#util.inspect">#</a></h3>

<p>Return a string representation of <code>object</code>, which is useful for debugging.</p>

<p>If <code>showHidden</code> is <code>true</code>, then the object's non-enumerable properties will be
shown too. Defaults to <code>false</code>.</p>

<p>If <code>depth</code> is provided, it tells <code>inspect</code> how many times to recurse while
formatting the object. This is useful for inspecting large complicated objects.</p>

<p>The default is to only recurse twice.  To make it recurse indefinitely, pass
in <code>null</code> for <code>depth</code>.</p>

<p>If <code>colors</code> is <code>true</code>, the output will be styled with ANSI color codes.
Defaults to <code>false</code>.</p>

<p>Example of inspecting all properties of the <code>util</code> object:</p>

<pre><code>var util = require('util');

console.log(util.inspect(util, true, null));</code></pre>

<h3 id="util.isArray">util.isArray(object) <a href="#util.isArray">#</a></h3>

<p>Returns <code>true</code> if the given "object" is an <code>Array</code>. <code>false</code> otherwise.</p>

<pre><code>var util = require('util');

util.isArray([])
  // true
util.isArray(new Array)
  // true
util.isArray({})
  // false</code></pre>

<h3 id="util.isRegExp">util.isRegExp(object) <a href="#util.isRegExp">#</a></h3>

<p>Returns <code>true</code> if the given "object" is a <code>RegExp</code>. <code>false</code> otherwise.</p>

<pre><code>var util = require('util');

util.isRegExp(/some regexp/)
  // true
util.isRegExp(new RegExp('another regexp'))
  // true
util.isRegExp({})
  // false</code></pre>

<h3 id="util.isDate">util.isDate(object) <a href="#util.isDate">#</a></h3>

<p>Returns <code>true</code> if the given "object" is a <code>Date</code>. <code>false</code> otherwise.</p>

<pre><code>var util = require('util');

util.isDate(new Date())
  // true
util.isDate(Date())
  // false (without 'new' returns a String)
util.isDate({})
  // false</code></pre>

<h3 id="util.isError">util.isError(object) <a href="#util.isError">#</a></h3>

<p>Returns <code>true</code> if the given "object" is an <code>Error</code>. <code>false</code> otherwise.</p>

<pre><code>var util = require('util');

util.isError(new Error())
  // true
util.isError(new TypeError())
  // true
util.isError({ name: 'Error', message: 'an error occurred' })
  // false</code></pre>

<h3 id="util.pump">util.pump(readableStream, writableStream, [callback]) <a href="#util.pump">#</a></h3>

<p>Experimental</p>

<p>Read the data from <code>readableStream</code> and send it to the <code>writableStream</code>.
When <code>writableStream.write(data)</code> returns <code>false</code> <code>readableStream</code> will be
paused until the <code>drain</code> event occurs on the <code>writableStream</code>. <code>callback</code> gets
an error as its only argument and is called when <code>writableStream</code> is closed or
when an error occurs.</p>

<h3 id="util.inherits">util.inherits(constructor, superConstructor) <a href="#util.inherits">#</a></h3>

<p>Inherit the prototype methods from one
<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/constructor">constructor</a>
into another.  The prototype of <code>constructor</code> will be set to a new
object created from <code>superConstructor</code>.</p>

<p>As an additional convenience, <code>superConstructor</code> will be accessible
through the <code>constructor.super_</code> property.</p>

<pre><code>var util = require("util");
var events = require("events");

function MyStream() {
    events.EventEmitter.call(this);
}

util.inherits(MyStream, events.EventEmitter);

MyStream.prototype.write = function(data) {
    this.emit("data", data);
}

var stream = new MyStream();

console.log(stream instanceof events.EventEmitter); // true
console.log(MyStream.super_ === events.EventEmitter); // true

stream.on("data", function(data) {
    console.log('Received data: "' + data + '"');
})
stream.write("It works!"); // Received data: "It works!"</code></pre>

<h2 id="events">Events</h2>

<p>Many objects in Node emit events: a <code>net.Server</code> emits an event each time
a peer connects to it, a <code>fs.readStream</code> emits an event when the file is
opened. All objects which emit events are instances of <code>events.EventEmitter</code>.
You can access this module by doing: <code>require("events");</code></p>

<p>Typically, event names are represented by a camel-cased string, however,
there aren't any strict restrictions on that, as any string will be accepted.</p>

<p>Functions can then be attached to objects, to be executed when an event
is emitted. These functions are called <em>listeners</em>.</p>

<h3 id="events.EventEmitter">events.EventEmitter <a href="#events.EventEmitter">#</a></h3>

<p>To access the EventEmitter class, <code>require('events').EventEmitter</code>.</p>

<p>When an <code>EventEmitter</code> instance experiences an error, the typical action is
to emit an <code>'error'</code> event.  Error events are treated as a special case in node.
If there is no listener for it, then the default action is to print a stack
trace and exit the program.</p>

<p>All EventEmitters emit the event <code>'newListener'</code> when new listeners are
added.</p>

<h4 id="emitter.addListener">emitter.addListener(event, listener) <a href="#emitter.addListener">#</a></h4>

<h4 id="emitter.on">emitter.on(event, listener) <a href="#emitter.on">#</a></h4>

<p>Adds a listener to the end of the listeners array for the specified event.</p>

<pre><code>server.on('connection', function (stream) {
  console.log('someone connected!');
});</code></pre>

<h4 id="emitter.once">emitter.once(event, listener) <a href="#emitter.once">#</a></h4>

<p>Adds a <strong>one time</strong> listener for the event. This listener is
invoked only the next time the event is fired, after which
it is removed.</p>

<pre><code>server.once('connection', function (stream) {
  console.log('Ah, we have our first user!');
});</code></pre>

<h4 id="emitter.removeListener">emitter.removeListener(event, listener) <a href="#emitter.removeListener">#</a></h4>

<p>Remove a listener from the listener array for the specified event.
<strong>Caution</strong>: changes array indices in the listener array behind the listener.</p>

<pre><code>var callback = function(stream) {
  console.log('someone connected!');
};
server.on('connection', callback);
// ...
server.removeListener('connection', callback);</code></pre>

<h4 id="emitter.removeAllListeners">emitter.removeAllListeners([event]) <a href="#emitter.removeAllListeners">#</a></h4>

<p>Removes all listeners, or those of the specified event.</p>

<h4 id="emitter.setMaxListeners">emitter.setMaxListeners(n) <a href="#emitter.setMaxListeners">#</a></h4>

<p>By default EventEmitters will print a warning if more than 10 listeners are
added for a particular event. This is a useful default which helps finding memory leaks.
Obviously not all Emitters should be limited to 10. This function allows
that to be increased. Set to zero for unlimited.</p>

<h4 id="emitter.listeners">emitter.listeners(event) <a href="#emitter.listeners">#</a></h4>

<p>Returns an array of listeners for the specified event. This array can be
manipulated, e.g. to remove listeners.</p>

<pre><code>server.on('connection', function (stream) {
  console.log('someone connected!');
});
console.log(util.inspect(server.listeners('connection'))); // [ [Function] ]</code></pre>

<h4 id="emitter.emit">emitter.emit(event, [arg1], [arg2], [...]) <a href="#emitter.emit">#</a></h4>

<p>Execute each of the listeners in order with the supplied arguments.</p>

<h4 id="event_newListener_">Event: 'newListener' <a href="#event_newListener_">#</a></h4>

<p><code>function (event, listener) { }</code></p>

<p>This event is emitted any time someone adds a new listener.</p>

<h2 id="buffers">Buffers</h2>

<p>Pure Javascript is Unicode friendly but not nice to binary data.  When
dealing with TCP streams or the file system, it's necessary to handle octet
streams. Node has several strategies for manipulating, creating, and
consuming octet streams.</p>

<p>Raw data is stored in instances of the <code>Buffer</code> class. A <code>Buffer</code> is similar
to an array of integers but corresponds to a raw memory allocation outside
the V8 heap. A <code>Buffer</code> cannot be resized.</p>

<p>The <code>Buffer</code> object is global.</p>

<p>Converting between Buffers and JavaScript string objects requires an explicit encoding
method.  Here are the different string encodings;</p>

<ul><li><p><code>'ascii'</code> - for 7 bit ASCII data only.  This encoding method is very fast, and will
strip the high bit if set.
Note that this encoding converts a null character (<code>'\0'</code> or <code>'\u0000'</code>) into
<code>0x20</code> (character code of a space). If you want to convert a null character
into <code>0x00</code>, you should use <code>'utf8'</code>.</p></li><li><p><code>'utf8'</code> - Multi byte encoded Unicode characters.  Many web pages and other document formats use UTF-8.</p></li><li><p><code>'ucs2'</code> - 2-bytes, little endian encoded Unicode characters. It can encode
only BMP(Basic Multilingual Plane, U+0000 - U+FFFF).</p></li><li><p><code>'base64'</code> - Base64 string encoding.</p></li><li><p><code>'binary'</code> - A way of encoding raw binary data into strings by using only
the first 8 bits of each character. This encoding method is deprecated and
should be avoided in favor of <code>Buffer</code> objects where possible. This encoding
will be removed in future versions of Node.</p></li><li><p><code>'hex'</code> - Encode each byte as two hexidecimal characters.</p></li></ul>

<h3 id="new_Buffer">new Buffer(size) <a href="#new_Buffer">#</a></h3>

<p>Allocates a new buffer of <code>size</code> octets.</p>

<h3 id="new_Buffer">new Buffer(array) <a href="#new_Buffer">#</a></h3>

<p>Allocates a new buffer using an <code>array</code> of octets.</p>

<h3 id="new_Buffer">new Buffer(str, [encoding]) <a href="#new_Buffer">#</a></h3>

<p>Allocates a new buffer containing the given <code>str</code>.
<code>encoding</code> defaults to <code>'utf8'</code>.</p>

<h3 id="buffer.write">buffer.write(string, [offset], [length], [encoding]) <a href="#buffer.write">#</a></h3>

<p>Writes <code>string</code> to the buffer at <code>offset</code> using the given encoding.
<code>offset</code> defaults to <code>0</code>, <code>encoding</code> defaults to <code>'utf8'</code>. <code>length</code> is
the number of bytes to write. Returns number of octets written. If <code>buffer</code> did
not contain enough space to fit the entire string, it will write a partial
amount of the string. <code>length</code> defaults to <code>buffer.length - offset</code>.
The method will not write partial characters.</p>

<pre><code>buf = new Buffer(256);
len = buf.write('\u00bd + \u00bc = \u00be', 0);
console.log(len + " bytes: " + buf.toString('utf8', 0, len));</code></pre>

<p>The number of characters written (which may be different than the number of
bytes written) is set in <code>Buffer._charsWritten</code> and will be overwritten the
next time <code>buf.write()</code> is called.</p>

<h3 id="buffer.toString">buffer.toString(encoding, [start], [end]) <a href="#buffer.toString">#</a></h3>

<p>Decodes and returns a string from buffer data encoded with <code>encoding</code>
(defaults to <code>'utf8'</code>) beginning at <code>start</code> (defaults to <code>0</code>) and ending at
<code>end</code> (defaults to <code>buffer.length</code>).</p>

<p>See <code>buffer.write()</code> example, above.</p>

<h3 id="buffer_index_">buffer[index] <a href="#buffer_index_">#</a></h3>

<p>Get and set the octet at <code>index</code>. The values refer to individual bytes,
so the legal range is between <code>0x00</code> and <code>0xFF</code> hex or <code>0</code> and <code>255</code>.</p>

<p>Example: copy an ASCII string into a buffer, one byte at a time:</p>

<pre><code>str = "node.js";
buf = new Buffer(str.length);

for (var i = 0; i &lt; str.length ; i++) {
  buf[i] = str.charCodeAt(i);
}

console.log(buf);

// node.js</code></pre>

<h3 id="buffer.isBuffer">Buffer.isBuffer(obj) <a href="#buffer.isBuffer">#</a></h3>

<p>Tests if <code>obj</code> is a <code>Buffer</code>.</p>

<h3 id="buffer.byteLength">Buffer.byteLength(string, [encoding]) <a href="#buffer.byteLength">#</a></h3>

<p>Gives the actual byte length of a string. <code>encoding</code> defaults to <code>'utf8'</code>.
This is not the same as <code>String.prototype.length</code> since that returns the
number of <em>characters</em> in a string.</p>

<p>Example:</p>

<pre><code>str = '\u00bd + \u00bc = \u00be';

console.log(str + ": " + str.length + " characters, " +
  Buffer.byteLength(str, 'utf8') + " bytes");

// ½ + ¼ = ¾: 9 characters, 12 bytes</code></pre>

<h3 id="buffer.length">buffer.length <a href="#buffer.length">#</a></h3>

<p>The size of the buffer in bytes.  Note that this is not necessarily the size
of the contents. <code>length</code> refers to the amount of memory allocated for the
buffer object.  It does not change when the contents of the buffer are changed.</p>

<pre><code>buf = new Buffer(1234);

console.log(buf.length);
buf.write("some string", "ascii", 0);
console.log(buf.length);

// 1234
// 1234</code></pre>

<h3 id="buffer.copy">buffer.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd]) <a href="#buffer.copy">#</a></h3>

<p>Does copy between buffers. The source and target regions can be overlapped.
<code>targetStart</code> and <code>sourceStart</code> default to <code>0</code>.
<code>sourceEnd</code> defaults to <code>buffer.length</code>.</p>

<p>Example: build two Buffers, then copy <code>buf1</code> from byte 16 through byte 19
into <code>buf2</code>, starting at the 8th byte in <code>buf2</code>.</p>

<pre><code>buf1 = new Buffer(26);
buf2 = new Buffer(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  buf1[i] = i + 97; // 97 is ASCII a
  buf2[i] = 33; // ASCII !
}

buf1.copy(buf2, 8, 16, 20);
console.log(buf2.toString('ascii', 0, 25));

// !!!!!!!!qrst!!!!!!!!!!!!!</code></pre>

<h3 id="buffer.slice">buffer.slice([start], [end]) <a href="#buffer.slice">#</a></h3>

<p>Returns a new buffer which references the same memory as the old, but offset
and cropped by the <code>start</code> (defaults to <code>0</code>) and <code>end</code> (defaults to
<code>buffer.length</code>) indexes.</p>

<p><strong>Modifying the new buffer slice will modify memory in the original buffer!</strong></p>

<p>Example: build a Buffer with the ASCII alphabet, take a slice, then modify one
byte from the original Buffer.</p>

<pre><code>var buf1 = new Buffer(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  buf1[i] = i + 97; // 97 is ASCII a
}

var buf2 = buf1.slice(0, 3);
console.log(buf2.toString('ascii', 0, buf2.length));
buf1[0] = 33;
console.log(buf2.toString('ascii', 0, buf2.length));

// abc
// !bc</code></pre>

<h3 id="buffer.readUInt8">buffer.readUInt8(offset, [noAssert]) <a href="#buffer.readUInt8">#</a></h3>

<p>Reads an unsigned 8 bit integer from the buffer at the specified offset.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.</p>

<p>Example:</p>

<pre><code>var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

for (ii = 0; ii &lt; buf.length; ii++) {
  console.log(buf.readUInt8(ii));
}

// 0x3
// 0x4
// 0x23
// 0x42</code></pre>

<h3 id="buffer.readUInt16LE">buffer.readUInt16LE(offset, [noAssert]) <a href="#buffer.readUInt16LE">#</a></h3>

<h3 id="buffer.readUInt16BE">buffer.readUInt16BE(offset, [noAssert]) <a href="#buffer.readUInt16BE">#</a></h3>

<p>Reads an unsigned 16 bit integer from the buffer at the specified offset with
specified endian format.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.</p>

<p>Example:</p>

<pre><code>var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

console.log(buf.readUInt16BE(0));
console.log(buf.readUInt16LE(0));
console.log(buf.readUInt16BE(1));
console.log(buf.readUInt16LE(1));
console.log(buf.readUInt16BE(2));
console.log(buf.readUInt16LE(2));

// 0x0304
// 0x0403
// 0x0423
// 0x2304
// 0x2342
// 0x4223</code></pre>

<h3 id="buffer.readUInt32LE">buffer.readUInt32LE(offset, [noAssert]) <a href="#buffer.readUInt32LE">#</a></h3>

<h3 id="buffer.readUInt32BE">buffer.readUInt32BE(offset, [noAssert]) <a href="#buffer.readUInt32BE">#</a></h3>

<p>Reads an unsigned 32 bit integer from the buffer at the specified offset with
specified endian format.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.</p>

<p>Example:</p>

<pre><code>var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

console.log(buf.readUInt32BE(0));
console.log(buf.readUInt32LE(0));

// 0x03042342
// 0x42230403</code></pre>

<h3 id="buffer.readInt8">buffer.readInt8(offset, [noAssert]) <a href="#buffer.readInt8">#</a></h3>

<p>Reads a signed 8 bit integer from the buffer at the specified offset.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.</p>

<p>Works as <code>buffer.readUInt8</code>, except buffer contents are treated as two's
complement signed values.</p>

<h3 id="buffer.readInt16LE">buffer.readInt16LE(offset, [noAssert]) <a href="#buffer.readInt16LE">#</a></h3>

<h3 id="buffer.readInt16BE">buffer.readInt16BE(offset, [noAssert]) <a href="#buffer.readInt16BE">#</a></h3>

<p>Reads a signed 16 bit integer from the buffer at the specified offset with
specified endian format.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.</p>

<p>Works as <code>buffer.readUInt16*</code>, except buffer contents are treated as two's
complement signed values.</p>

<h3 id="buffer.readInt32LE">buffer.readInt32LE(offset, [noAssert]) <a href="#buffer.readInt32LE">#</a></h3>

<h3 id="buffer.readInt32BE">buffer.readInt32BE(offset, [noAssert]) <a href="#buffer.readInt32BE">#</a></h3>

<p>Reads a signed 32 bit integer from the buffer at the specified offset with
specified endian format.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.</p>

<p>Works as <code>buffer.readUInt32*</code>, except buffer contents are treated as two's
complement signed values.</p>

<h3 id="buffer.readFloatLE">buffer.readFloatLE(offset, [noAssert]) <a href="#buffer.readFloatLE">#</a></h3>

<h3 id="buffer.readFloatBE">buffer.readFloatBE(offset, [noAssert]) <a href="#buffer.readFloatBE">#</a></h3>

<p>Reads a 32 bit float from the buffer at the specified offset with specified
endian format.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.</p>

<p>Example:</p>

<pre><code>var buf = new Buffer(4);

buf[0] = 0x00;
buf[1] = 0x00;
buf[2] = 0x80;
buf[3] = 0x3f;

console.log(buf.readFloatLE(0));

// 0x01</code></pre>

<h3 id="buffer.readDoubleLE">buffer.readDoubleLE(offset, [noAssert]) <a href="#buffer.readDoubleLE">#</a></h3>

<h3 id="buffer.readDoubleBE">buffer.readDoubleBE(offset, [noAssert]) <a href="#buffer.readDoubleBE">#</a></h3>

<p>Reads a 64 bit double from the buffer at the specified offset with specified
endian format.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.</p>

<p>Example:</p>

<pre><code>var buf = new Buffer(8);

buf[0] = 0x55;
buf[1] = 0x55;
buf[2] = 0x55;
buf[3] = 0x55;
buf[4] = 0x55;
buf[5] = 0x55;
buf[6] = 0xd5;
buf[7] = 0x3f;

console.log(buf.readDoubleLE(0));

// 0.3333333333333333</code></pre>

<h3 id="buffer.writeUInt8">buffer.writeUInt8(value, offset, [noAssert]) <a href="#buffer.writeUInt8">#</a></h3>

<p>Writes <code>value</code> to the buffer at the specified offset. Note, <code>value</code> must be a
valid unsigned 8 bit integer.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.</p>

<p>Example:</p>

<pre><code>var buf = new Buffer(4);
buf.writeUInt8(0x3, 0);
buf.writeUInt8(0x4, 1);
buf.writeUInt8(0x23, 2);
buf.writeUInt8(0x42, 3);

console.log(buf);

// &lt;Buffer 03 04 23 42&gt;</code></pre>

<h3 id="buffer.writeUInt16LE">buffer.writeUInt16LE(value, offset, [noAssert]) <a href="#buffer.writeUInt16LE">#</a></h3>

<h3 id="buffer.writeUInt16BE">buffer.writeUInt16BE(value, offset, [noAssert]) <a href="#buffer.writeUInt16BE">#</a></h3>

<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid unsigned 16 bit integer.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.</p>

<p>Example:</p>

<pre><code>var buf = new Buffer(4);
buf.writeUInt16BE(0xdead, 0);
buf.writeUInt16BE(0xbeef, 2);

console.log(buf);

buf.writeUInt16LE(0xdead, 0);
buf.writeUInt16LE(0xbeef, 2);

console.log(buf);

// &lt;Buffer de ad be ef&gt;
// &lt;Buffer ad de ef be&gt;</code></pre>

<h3 id="buffer.writeUInt32LE">buffer.writeUInt32LE(value, offset, [noAssert]) <a href="#buffer.writeUInt32LE">#</a></h3>

<h3 id="buffer.writeUInt32BE">buffer.writeUInt32BE(value, offset, [noAssert]) <a href="#buffer.writeUInt32BE">#</a></h3>

<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid unsigned 32 bit integer.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.</p>

<p>Example:</p>

<pre><code>var buf = new Buffer(4);
buf.writeUInt32BE(0xfeedface, 0);

console.log(buf);

buf.writeUInt32LE(0xfeedface, 0);

console.log(buf);

// &lt;Buffer fe ed fa ce&gt;
// &lt;Buffer ce fa ed fe&gt;</code></pre>

<h3 id="buffer.writeInt8">buffer.writeInt8(value, offset, [noAssert]) <a href="#buffer.writeInt8">#</a></h3>

<p>Writes <code>value</code> to the buffer at the specified offset. Note, <code>value</code> must be a
valid signed 8 bit integer.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.</p>

<p>Works as <code>buffer.writeUInt8</code>, except value is written out as a two's complement
signed integer into <code>buffer</code>.</p>

<h3 id="buffer.writeInt16LE">buffer.writeInt16LE(value, offset, [noAssert]) <a href="#buffer.writeInt16LE">#</a></h3>

<h3 id="buffer.writeInt16BE">buffer.writeInt16BE(value, offset, [noAssert]) <a href="#buffer.writeInt16BE">#</a></h3>

<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid signed 16 bit integer.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.</p>

<p>Works as <code>buffer.writeUInt16*</code>, except value is written out as a two's
complement signed integer into <code>buffer</code>.</p>

<h3 id="buffer.writeInt32LE">buffer.writeInt32LE(value, offset, [noAssert]) <a href="#buffer.writeInt32LE">#</a></h3>

<h3 id="buffer.writeInt32BE">buffer.writeInt32BE(value, offset, [noAssert]) <a href="#buffer.writeInt32BE">#</a></h3>

<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid signed 32 bit integer.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.</p>

<p>Works as <code>buffer.writeUInt32*</code>, except value is written out as a two's
complement signed integer into <code>buffer</code>.</p>

<h3 id="buffer.writeFloatLE">buffer.writeFloatLE(value, offset, [noAssert]) <a href="#buffer.writeFloatLE">#</a></h3>

<h3 id="buffer.writeFloatBE">buffer.writeFloatBE(value, offset, [noAssert]) <a href="#buffer.writeFloatBE">#</a></h3>

<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid 32 bit float.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.</p>

<p>Example:</p>

<pre><code>var buf = new Buffer(4);
buf.writeFloatBE(0xcafebabe, 0);

console.log(buf);

buf.writeFloatLE(0xcafebabe, 0);

console.log(buf);

// &lt;Buffer 4f 4a fe bb&gt;
// &lt;Buffer bb fe 4a 4f&gt;</code></pre>

<h3 id="buffer.writeDoubleLE">buffer.writeDoubleLE(value, offset, [noAssert]) <a href="#buffer.writeDoubleLE">#</a></h3>

<h3 id="buffer.writeDoubleBE">buffer.writeDoubleBE(value, offset, [noAssert]) <a href="#buffer.writeDoubleBE">#</a></h3>

<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid 64 bit double.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.</p>

<p>Example:</p>

<pre><code>var buf = new Buffer(8);
buf.writeDoubleBE(0xdeadbeefcafebabe, 0);

console.log(buf);

buf.writeDoubleLE(0xdeadbeefcafebabe, 0);

console.log(buf);

// &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;
// &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;</code></pre>

<h3 id="buffer.fill">buffer.fill(value, [offset], [end]) <a href="#buffer.fill">#</a></h3>

<p>Fills the buffer with the specified value. If the <code>offset</code> (defaults to <code>0</code>)
and <code>end</code> (defaults to <code>buffer.length</code>) are not given it will fill the entire
buffer.</p>

<pre><code>var b = new Buffer(50);
b.fill("h");</code></pre>

<h3 id="iNSPECT_MAX_BYTES">INSPECT_MAX_BYTES <a href="#iNSPECT_MAX_BYTES">#</a></h3>

<p>How many bytes will be returned when <code>buffer.inspect()</code> is called. This can
be overridden by user modules.</p>

<h2 id="streams">Streams</h2>

<p>A stream is an abstract interface implemented by various objects in Node.
For example a request to an HTTP server is a stream, as is stdout. Streams
are readable, writable, or both. All streams are instances of <code>EventEmitter</code>.</p>

<h2 id="readable_Stream">Readable Stream</h2>

<p>A <code>Readable Stream</code> has the following methods, members, and events.</p>

<h3 id="event_data_">Event: 'data' <a href="#event_data_">#</a></h3>

<p><code>function (data) { }</code></p>

<p>The <code>'data'</code> event emits either a <code>Buffer</code> (by default) or a string if
<code>setEncoding()</code> was used.</p>

<h3 id="event_end_">Event: 'end' <a href="#event_end_">#</a></h3>

<p><code>function () { }</code></p>

<p>Emitted when the stream has received an EOF (FIN in TCP terminology).
Indicates that no more <code>'data'</code> events will happen. If the stream is also
writable, it may be possible to continue writing.</p>

<h3 id="event_error_">Event: 'error' <a href="#event_error_">#</a></h3>

<p><code>function (exception) { }</code></p>

<p>Emitted if there was an error receiving data.</p>

<h3 id="event_close_">Event: 'close' <a href="#event_close_">#</a></h3>

<p><code>function () { }</code></p>

<p>Emitted when the underlying file descriptor has been closed. Not all streams
will emit this.  (For example, an incoming HTTP request will not emit
<code>'close'</code>.)</p>

<h3 id="stream.readable">stream.readable <a href="#stream.readable">#</a></h3>

<p>A boolean that is <code>true</code> by default, but turns <code>false</code> after an <code>'error'</code>
occurred, the stream came to an <code>'end'</code>, or <code>destroy()</code> was called.</p>

<h3 id="stream.setEncoding">stream.setEncoding(encoding) <a href="#stream.setEncoding">#</a></h3>

<p>Makes the data event emit a string instead of a <code>Buffer</code>. <code>encoding</code> can be
<code>'utf8'</code>, <code>'ascii'</code>, or <code>'base64'</code>.</p>

<h3 id="stream.pause">stream.pause() <a href="#stream.pause">#</a></h3>

<p>Pauses the incoming <code>'data'</code> events.</p>

<h3 id="stream.resume">stream.resume() <a href="#stream.resume">#</a></h3>

<p>Resumes the incoming <code>'data'</code> events after a <code>pause()</code>.</p>

<h3 id="stream.destroy">stream.destroy() <a href="#stream.destroy">#</a></h3>

<p>Closes the underlying file descriptor. Stream will not emit any more events.</p>

<h3 id="stream.destroySoon">stream.destroySoon() <a href="#stream.destroySoon">#</a></h3>

<p>After the write queue is drained, close the file descriptor.</p>

<h3 id="stream.pipe">stream.pipe(destination, [options]) <a href="#stream.pipe">#</a></h3>

<p>This is a <code>Stream.prototype</code> method available on all <code>Stream</code>s.</p>

<p>Connects this read stream to <code>destination</code> WriteStream. Incoming
data on this stream gets written to <code>destination</code>. The destination and source
streams are kept in sync by pausing and resuming as necessary.</p>

<p>This function returns the <code>destination</code> stream.</p>

<p>Emulating the Unix <code>cat</code> command:</p>

<pre><code>process.stdin.resume();
process.stdin.pipe(process.stdout);</code></pre>

<p>By default <code>end()</code> is called on the destination when the source stream emits
<code>end</code>, so that <code>destination</code> is no longer writable. Pass <code>{ end: false }</code> as
<code>options</code> to keep the destination stream open.</p>

<p>This keeps <code>process.stdout</code> open so that "Goodbye" can be written at the end.</p>

<pre><code>process.stdin.resume();

process.stdin.pipe(process.stdout, { end: false });

process.stdin.on("end", function() {
  process.stdout.write("Goodbye\n");
});</code></pre>

<h2 id="writable_Stream">Writable Stream</h2>

<p>A <code>Writable Stream</code> has the following methods, members, and events.</p>

<h3 id="event_drain_">Event: 'drain' <a href="#event_drain_">#</a></h3>

<p><code>function () { }</code></p>

<p>After a <code>write()</code> method returned <code>false</code>, this event is emitted to
indicate that it is safe to write again.</p>

<h3 id="event_error_">Event: 'error' <a href="#event_error_">#</a></h3>

<p><code>function (exception) { }</code></p>

<p>Emitted on error with the exception <code>exception</code>.</p>

<h3 id="event_close_">Event: 'close' <a href="#event_close_">#</a></h3>

<p><code>function () { }</code></p>

<p>Emitted when the underlying file descriptor has been closed.</p>

<h3 id="event_pipe_">Event: 'pipe' <a href="#event_pipe_">#</a></h3>

<p><code>function (src) { }</code></p>

<p>Emitted when the stream is passed to a readable stream's pipe method.</p>

<h3 id="stream.writable">stream.writable <a href="#stream.writable">#</a></h3>

<p>A boolean that is <code>true</code> by default, but turns <code>false</code> after an <code>'error'</code>
occurred or <code>end()</code> / <code>destroy()</code> was called.</p>

<h3 id="stream.write">stream.write(string, [encoding], [fd]) <a href="#stream.write">#</a></h3>

<p>Writes <code>string</code> with the given <code>encoding</code> to the stream.  Returns <code>true</code> if
the string has been flushed to the kernel buffer.  Returns <code>false</code> to
indicate that the kernel buffer is full, and the data will be sent out in
the future. The <code>'drain'</code> event will indicate when the kernel buffer is
empty again. The <code>encoding</code> defaults to <code>'utf8'</code>.</p>

<p>If the optional <code>fd</code> parameter is specified, it is interpreted as an integral
file descriptor to be sent over the stream. This is only supported for UNIX
streams, and is silently ignored otherwise. When writing a file descriptor in
this manner, closing the descriptor before the stream drains risks sending an
invalid (closed) FD.</p>

<h3 id="stream.write">stream.write(buffer) <a href="#stream.write">#</a></h3>

<p>Same as the above except with a raw buffer.</p>

<h3 id="stream.end">stream.end() <a href="#stream.end">#</a></h3>

<p>Terminates the stream with EOF or FIN.
This call will allow queued write data to be sent before closing the stream.</p>

<h3 id="stream.end">stream.end(string, encoding) <a href="#stream.end">#</a></h3>

<p>Sends <code>string</code> with the given <code>encoding</code> and terminates the stream with EOF
or FIN. This is useful to reduce the number of packets sent.</p>

<h3 id="stream.end">stream.end(buffer) <a href="#stream.end">#</a></h3>

<p>Same as above but with a <code>buffer</code>.</p>

<h3 id="stream.destroy">stream.destroy() <a href="#stream.destroy">#</a></h3>

<p>Closes the underlying file descriptor. Stream will not emit any more events.
Any queued write data will not be sent.</p>

<h3 id="stream.destroySoon">stream.destroySoon() <a href="#stream.destroySoon">#</a></h3>

<p>After the write queue is drained, close the file descriptor. <code>destroySoon()</code>
can still destroy straight away, as long as there is no data left in the queue
for writes.</p>

<h2 id="crypto">Crypto</h2>

<p>Use <code>require('crypto')</code> to access this module.</p>

<p>The crypto module requires OpenSSL to be available on the underlying platform.
It offers a way of encapsulating secure credentials to be used as part
of a secure HTTPS net or http connection.</p>

<p>It also offers a set of wrappers for OpenSSL's hash, hmac, cipher, decipher, sign and verify methods.</p>

<h3 id="crypto.createCredentials">crypto.createCredentials(details) <a href="#crypto.createCredentials">#</a></h3>

<p>Creates a credentials object, with the optional details being a dictionary with keys:</p>

<ul><li><code>key</code> : a string holding the PEM encoded private key</li><li><code>cert</code> : a string holding the PEM encoded certificate</li><li><code>ca</code> : either a string or list of strings of PEM encoded CA certificates to trust.</li></ul>

<p>If no 'ca' details are given, then node.js will use the default publicly trusted list of CAs as given in
<a href="http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>.</p>

<h3 id="crypto.createHash">crypto.createHash(algorithm) <a href="#crypto.createHash">#</a></h3>

<p>Creates and returns a hash object, a cryptographic hash with the given algorithm
which can be used to generate hash digests.</p>

<p><code>algorithm</code> is dependent on the available algorithms supported by the version
of OpenSSL on the platform. Examples are <code>'sha1'</code>, <code>'md5'</code>, <code>'sha256'</code>, <code>'sha512'</code>, etc.
On recent releases, <code>openssl list-message-digest-algorithms</code> will display the available digest algorithms.</p>

<p>Example: this program that takes the sha1 sum of a file</p>

<pre><code>var filename = process.argv[2];
var crypto = require('crypto');
var fs = require('fs');

var shasum = crypto.createHash('sha1');

var s = fs.ReadStream(filename);
s.on('data', function(d) {
  shasum.update(d);
});

s.on('end', function() {
  var d = shasum.digest('hex');
  console.log(d + '  ' + filename);
});</code></pre>

<h3 id="hash.update">hash.update(data, [input_encoding]) <a href="#hash.update">#</a></h3>

<p>Updates the hash content with the given <code>data</code>, the encoding of which is given
in <code>input_encoding</code> and can be <code>'utf8'</code>, <code>'ascii'</code> or <code>'binary'</code>.
Defaults to <code>'binary'</code>.
This can be called many times with new data as it is streamed.</p>

<h3 id="hash.digest">hash.digest([encoding]) <a href="#hash.digest">#</a></h3>

<p>Calculates the digest of all of the passed data to be hashed.
The <code>encoding</code> can be <code>'hex'</code>, <code>'binary'</code> or <code>'base64'</code>.
Defaults to <code>'binary'</code>.</p>

<p>Note: <code>hash</code> object can not be used after <code>digest()</code> method been called.</p>

<h3 id="crypto.createHmac">crypto.createHmac(algorithm, key) <a href="#crypto.createHmac">#</a></h3>

<p>Creates and returns a hmac object, a cryptographic hmac with the given algorithm and key.</p>

<p><code>algorithm</code> is dependent on the available algorithms supported by OpenSSL - see createHash above.
<code>key</code> is the hmac key to be used.</p>

<h3 id="hmac.update">hmac.update(data) <a href="#hmac.update">#</a></h3>

<p>Update the hmac content with the given <code>data</code>.
This can be called many times with new data as it is streamed.</p>

<h3 id="hmac.digest">hmac.digest([encoding]) <a href="#hmac.digest">#</a></h3>

<p>Calculates the digest of all of the passed data to the hmac.
The <code>encoding</code> can be <code>'hex'</code>, <code>'binary'</code> or <code>'base64'</code>.
Defaults to <code>'binary'</code>.</p>

<p>Note: <code>hmac</code> object can not be used after <code>digest()</code> method been called.</p>

<h3 id="crypto.createCipher">crypto.createCipher(algorithm, password) <a href="#crypto.createCipher">#</a></h3>

<p>Creates and returns a cipher object, with the given algorithm and password.</p>

<p><code>algorithm</code> is dependent on OpenSSL, examples are <code>'aes192'</code>, etc.
On recent releases, <code>openssl list-cipher-algorithms</code> will display the
available cipher algorithms.
<code>password</code> is used to derive key and IV, which must be <code>'binary'</code> encoded
string (See the <a href="buffers.html">Buffers</a> for more information).</p>

<h3 id="crypto.createCipheriv">crypto.createCipheriv(algorithm, key, iv) <a href="#crypto.createCipheriv">#</a></h3>

<p>Creates and returns a cipher object, with the given algorithm, key and iv.</p>

<p><code>algorithm</code> is the same as the <code>createCipher()</code>. <code>key</code> is a raw key used in
algorithm. <code>iv</code> is an Initialization vector. <code>key</code> and <code>iv</code> must be <code>'binary'</code>
encoded string (See the <a href="buffers.html">Buffers</a> for more information).</p>

<h3 id="cipher.update">cipher.update(data, [input_encoding], [output_encoding]) <a href="#cipher.update">#</a></h3>

<p>Updates the cipher with <code>data</code>, the encoding of which is given in
<code>input_encoding</code> and can be <code>'utf8'</code>, <code>'ascii'</code> or <code>'binary'</code>.
Defaults to <code>'binary'</code>.</p>

<p>The <code>output_encoding</code> specifies the output format of the enciphered data,
and can be <code>'binary'</code>, <code>'base64'</code> or <code>'hex'</code>. Defaults to <code>'binary'</code>.</p>

<p>Returns the enciphered contents, and can be called many times with new data as it is streamed.</p>

<h3 id="cipher.final">cipher.final([output_encoding]) <a href="#cipher.final">#</a></h3>

<p>Returns any remaining enciphered contents, with <code>output_encoding</code> being one of:
<code>'binary'</code>, <code>'base64'</code> or <code>'hex'</code>. Defaults to <code>'binary'</code>.</p>

<p>Note: <code>cipher</code> object can not be used after <code>final()</code> method been called.</p>

<h3 id="crypto.createDecipher">crypto.createDecipher(algorithm, password) <a href="#crypto.createDecipher">#</a></h3>

<p>Creates and returns a decipher object, with the given algorithm and key.
This is the mirror of the <a href="#crypto.createCipher">createCipher()</a> above.</p>

<h3 id="crypto.createDecipheriv">crypto.createDecipheriv(algorithm, key, iv) <a href="#crypto.createDecipheriv">#</a></h3>

<p>Creates and returns a decipher object, with the given algorithm, key and iv.
This is the mirror of the <a href="#crypto.createCipheriv">createCipheriv()</a> above.</p>

<h3 id="decipher.update">decipher.update(data, [input_encoding], [output_encoding]) <a href="#decipher.update">#</a></h3>

<p>Updates the decipher with <code>data</code>, which is encoded in <code>'binary'</code>, <code>'base64'</code>
or <code>'hex'</code>. Defaults to <code>'binary'</code>.</p>

<p>The <code>output_decoding</code> specifies in what format to return the deciphered
plaintext: <code>'binary'</code>, <code>'ascii'</code> or <code>'utf8'</code>. Defaults to <code>'binary'</code>.</p>

<h3 id="decipher.final">decipher.final([output_encoding]) <a href="#decipher.final">#</a></h3>

<p>Returns any remaining plaintext which is deciphered,
with <code>output_encoding</code> being one of: <code>'binary'</code>, <code>'ascii'</code> or <code>'utf8'</code>.
Defaults to <code>'binary'</code>.</p>

<p>Note: <code>decipher</code> object can not be used after <code>final()</code> method been called.</p>

<h3 id="crypto.createSign">crypto.createSign(algorithm) <a href="#crypto.createSign">#</a></h3>

<p>Creates and returns a signing object, with the given algorithm.
On recent OpenSSL releases, <code>openssl list-public-key-algorithms</code> will display
the available signing algorithms. Examples are <code>'RSA-SHA256'</code>.</p>

<h3 id="signer.update">signer.update(data) <a href="#signer.update">#</a></h3>

<p>Updates the signer object with data.
This can be called many times with new data as it is streamed.</p>

<h3 id="signer.sign">signer.sign(private_key, [output_format]) <a href="#signer.sign">#</a></h3>

<p>Calculates the signature on all the updated data passed through the signer.
<code>private_key</code> is a string containing the PEM encoded private key for signing.</p>

<p>Returns the signature in <code>output_format</code> which can be <code>'binary'</code>, <code>'hex'</code> or
<code>'base64'</code>. Defaults to <code>'binary'</code>.</p>

<p>Note: <code>signer</code> object can not be used after <code>sign()</code> method been called.</p>

<h3 id="crypto.createVerify">crypto.createVerify(algorithm) <a href="#crypto.createVerify">#</a></h3>

<p>Creates and returns a verification object, with the given algorithm.
This is the mirror of the signing object above.</p>

<h3 id="verifier.update">verifier.update(data) <a href="#verifier.update">#</a></h3>

<p>Updates the verifier object with data.
This can be called many times with new data as it is streamed.</p>

<h3 id="verifier.verify">verifier.verify(object, signature, [signature_format]) <a href="#verifier.verify">#</a></h3>

<p>Verifies the signed data by using the <code>object</code> and <code>signature</code>. <code>object</code> is  a
string containing a PEM encoded object, which can be one of RSA public key,
DSA public key, or X.509 certificate. <code>signature</code> is the previously calculated
signature for the data, in the <code>signature_format</code> which can be <code>'binary'</code>,
<code>'hex'</code> or <code>'base64'</code>. Defaults to <code>'binary'</code>.</p>

<p>Returns true or false depending on the validity of the signature for the data and public key.</p>

<p>Note: <code>verifier</code> object can not be used after <code>verify()</code> method been called.</p>

<h3 id="crypto.createDiffieHellman">crypto.createDiffieHellman(prime_length) <a href="#crypto.createDiffieHellman">#</a></h3>

<p>Creates a Diffie-Hellman key exchange object and generates a prime of the
given bit length. The generator used is <code>2</code>.</p>

<h3 id="crypto.createDiffieHellman">crypto.createDiffieHellman(prime, [encoding]) <a href="#crypto.createDiffieHellman">#</a></h3>

<p>Creates a Diffie-Hellman key exchange object using the supplied prime. The
generator used is <code>2</code>. Encoding can be <code>'binary'</code>, <code>'hex'</code>, or <code>'base64'</code>.
Defaults to <code>'binary'</code>.</p>

<h3 id="diffieHellman.generateKeys">diffieHellman.generateKeys([encoding]) <a href="#diffieHellman.generateKeys">#</a></h3>

<p>Generates private and public Diffie-Hellman key values, and returns the
public key in the specified encoding. This key should be transferred to the
other party. Encoding can be <code>'binary'</code>, <code>'hex'</code>, or <code>'base64'</code>.
Defaults to <code>'binary'</code>.</p>

<h3 id="diffieHellman.computeSecret">diffieHellman.computeSecret(other_public_key, [input_encoding], [output_encoding]) <a href="#diffieHellman.computeSecret">#</a></h3>

<p>Computes the shared secret using <code>other_public_key</code> as the other party's
public key and returns the computed shared secret. Supplied key is
interpreted using specified <code>input_encoding</code>, and secret is encoded using
specified <code>output_encoding</code>. Encodings can be <code>'binary'</code>, <code>'hex'</code>, or
<code>'base64'</code>. The input encoding defaults to <code>'binary'</code>.
If no output encoding is given, the input encoding is used as output encoding.</p>

<h3 id="diffieHellman.getPrime">diffieHellman.getPrime([encoding]) <a href="#diffieHellman.getPrime">#</a></h3>

<p>Returns the Diffie-Hellman prime in the specified encoding, which can be
<code>'binary'</code>, <code>'hex'</code>, or <code>'base64'</code>. Defaults to <code>'binary'</code>.</p>

<h3 id="diffieHellman.getGenerator">diffieHellman.getGenerator([encoding]) <a href="#diffieHellman.getGenerator">#</a></h3>

<p>Returns the Diffie-Hellman prime in the specified encoding, which can be
<code>'binary'</code>, <code>'hex'</code>, or <code>'base64'</code>. Defaults to <code>'binary'</code>.</p>

<h3 id="diffieHellman.getPublicKey">diffieHellman.getPublicKey([encoding]) <a href="#diffieHellman.getPublicKey">#</a></h3>

<p>Returns the Diffie-Hellman public key in the specified encoding, which can
be <code>'binary'</code>, <code>'hex'</code>, or <code>'base64'</code>. Defaults to <code>'binary'</code>.</p>

<h3 id="diffieHellman.getPrivateKey">diffieHellman.getPrivateKey([encoding]) <a href="#diffieHellman.getPrivateKey">#</a></h3>

<p>Returns the Diffie-Hellman private key in the specified encoding, which can
be <code>'binary'</code>, <code>'hex'</code>, or <code>'base64'</code>. Defaults to <code>'binary'</code>.</p>

<h3 id="diffieHellman.setPublicKey">diffieHellman.setPublicKey(public_key, [encoding]) <a href="#diffieHellman.setPublicKey">#</a></h3>

<p>Sets the Diffie-Hellman public key. Key encoding can be <code>'binary'</code>, <code>'hex'</code>,
or <code>'base64'</code>. Defaults to <code>'binary'</code>.</p>

<h3 id="diffieHellman.setPrivateKey">diffieHellman.setPrivateKey(public_key, [encoding]) <a href="#diffieHellman.setPrivateKey">#</a></h3>

<p>Sets the Diffie-Hellman private key. Key encoding can be <code>'binary'</code>, <code>'hex'</code>,
or <code>'base64'</code>. Defaults to <code>'binary'</code>.</p>

<h3 id="pbkdf2">pbkdf2(password, salt, iterations, keylen, callback) <a href="#pbkdf2">#</a></h3>

<p>Asynchronous PBKDF2 applies pseudorandom function HMAC-SHA1 to derive
a key of given length from the given password, salt and iterations.
The callback gets two arguments <code>(err, derivedKey)</code>.</p>

<h3 id="randomBytes">randomBytes(size, [callback]) <a href="#randomBytes">#</a></h3>

<p>Generates cryptographically strong pseudo-random data. Usage:</p>

<pre><code>// async
crypto.randomBytes(256, function(ex, buf) {
  if (ex) throw ex;
  console.log('Have %d bytes of random data: %s', buf.length, buf);
});

// sync
try {
  var buf = crypto.randomBytes(256);
  console.log('Have %d bytes of random data: %s', buf.length, buf);
} catch (ex) {
  // handle error
}</code></pre>

<h2 id="tLS_">TLS (SSL)</h2>

<p>Use <code>require('tls')</code> to access this module.</p>

<p>The <code>tls</code> module uses OpenSSL to provide Transport Layer Security and/or
Secure Socket Layer: encrypted stream communication.</p>

<p>TLS/SSL is a public/private key infrastructure. Each client and each
server must have a private key. A private key is created like this</p>

<pre><code>openssl genrsa -out ryans-key.pem 1024</code></pre>

<p>All severs and some clients need to have a certificate. Certificates are public
keys signed by a Certificate Authority or self-signed. The first step to
getting a certificate is to create a "Certificate Signing Request" (CSR)
file. This is done with:</p>

<pre><code>openssl req -new -key ryans-key.pem -out ryans-csr.pem</code></pre>

<p>To create a self-signed certificate with the CSR, do this:</p>

<pre><code>openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem</code></pre>

<p>Alternatively you can send the CSR to a Certificate Authority for signing.</p>

<p>(TODO: docs on creating a CA, for now interested users should just look at
<code>test/fixtures/keys/Makefile</code> in the Node source code)</p>

<h4 id="tls.createServer">tls.createServer(options, [secureConnectionListener]) <a href="#tls.createServer">#</a></h4>

<p>Creates a new <a href="#tls.Server">tls.Server</a>.
The <code>connectionListener</code> argument is automatically set as a listener for the
<a href="#event_secureConnection_">secureConnection</a> event.
The <code>options</code> object has these possibilities:</p>

<ul><li><p><code>key</code>: A string or <code>Buffer</code> containing the private key of the server in
PEM format. (Required)</p></li><li><p><code>passphrase</code>: A string of passphrase for the private key.</p></li><li><p><code>cert</code>: A string or <code>Buffer</code> containing the certificate key of the server in
PEM format. (Required)</p></li><li><p><code>ca</code>: An array of strings or <code>Buffer</code>s of trusted certificates. If this is
omitted several well known "root" CAs will be used, like VeriSign.
These are used to authorize connections.</p></li><li><p><code>requestCert</code>: If <code>true</code> the server will request a certificate from
clients that connect and attempt to verify that certificate. Default:
<code>false</code>.</p></li><li><p><code>rejectUnauthorized</code>: If <code>true</code> the server will reject any connection
which is not authorized with the list of supplied CAs. This option only
has an effect if <code>requestCert</code> is <code>true</code>. Default: <code>false</code>.</p></li><li><p><code>NPNProtocols</code>: An array or <code>Buffer</code> of possible NPN protocols. (Protocols
should be ordered by their priority).</p></li><li><p><code>SNICallback</code>: A function that will be called if client supports SNI TLS
extension. Only one argument will be passed to it: <code>servername</code>. And
<code>SNICallback</code> should return SecureContext instance.
(You can use <code>crypto.createCredentials(...).context</code> to get proper
SecureContext). If <code>SNICallback</code> wasn't provided - default callback with
high-level API will be used (see below).</p></li><li><p><code>sessionIdContext</code>: A string containing a opaque identifier for session
resumption. If <code>requestCert</code> is <code>true</code>, the default is MD5 hash value
generated from command-line. Otherwise, the default is not provided.</p></li></ul>

<p>Here is a simple example echo server:</p>

<pre><code>var tls = require('tls');
var fs = require('fs');

var options = {
  key: fs.readFileSync('server-key.pem'),
  cert: fs.readFileSync('server-cert.pem'),

  // This is necessary only if using the client certificate authentication.
  requestCert: true,

  // This is necessary only if the client uses the self-signed certificate.
  ca: [ fs.readFileSync('client-cert.pem') ]
};

var server = tls.createServer(options, function(cleartextStream) {
  console.log('server connected',
              cleartextStream.authorized ? 'authorized' : 'unauthorized');
  cleartextStream.write("welcome!\n");
  cleartextStream.setEncoding('utf8');
  cleartextStream.pipe(cleartextStream);
});
server.listen(8000, function() {
  console.log('server bound');
});</code></pre>

<p>You can test this server by connecting to it with <code>openssl s_client</code>:</p>

<pre><code>openssl s_client -connect 127.0.0.1:8000</code></pre>

<h4 id="tls.connect">tls.connect(port, [host], [options], [secureConnectListener]) <a href="#tls.connect">#</a></h4>

<p>Creates a new client connection to the given <code>port</code> and <code>host</code>. (If <code>host</code>
defaults to <code>localhost</code>.) <code>options</code> should be an object which specifies</p>

<ul><li><p><code>key</code>: A string or <code>Buffer</code> containing the private key of the client in
PEM format.</p></li><li><p><code>passphrase</code>: A string of passphrase for the private key.</p></li><li><p><code>cert</code>: A string or <code>Buffer</code> containing the certificate key of the client in
PEM format.</p></li><li><p><code>ca</code>: An array of strings or <code>Buffer</code>s of trusted certificates. If this is
omitted several well known "root" CAs will be used, like VeriSign.
These are used to authorize connections.</p></li><li><p><code>NPNProtocols</code>: An array of string or <code>Buffer</code> containing supported NPN
protocols. <code>Buffer</code> should have following format: <code>0x05hello0x05world</code>,
where first byte is next protocol name's length. (Passing array should
usually be much simpler: <code>['hello', 'world']</code>.)</p></li><li><p><code>servername</code>: Servername for SNI (Server Name Indication) TLS extension.</p></li></ul>

<p>The <code>secureConnectListener</code> parameter will be added as a listener for the
<a href="#event_secureConnect_">'secureConnect'</a> event.</p>

<p><code>tls.connect()</code> returns a <a href="#tls.CleartextStream">CleartextStream</a> object.</p>

<p>Here is an example of a client of echo server as described previously:</p>

<pre><code>var tls = require('tls');
var fs = require('fs');

var options = {
  // These are necessary only if using the client certificate authentication
  key: fs.readFileSync('client-key.pem'),
  cert: fs.readFileSync('client-cert.pem'),

  // This is necessary only if the server uses the self-signed certificate
  ca: [ fs.readFileSync('server-cert.pem') ]
};

var cleartextStream = tls.connect(8000, options, function() {
  console.log('client connected',
              cleartextStream.authorized ? 'authorized' : 'unauthorized');
  process.stdin.pipe(cleartextStream);
  process.stdin.resume();
});
cleartextStream.setEncoding('utf8');
cleartextStream.on('data', function(data) {
  console.log(data);
});
cleartextStream.on('end', function() {
  server.close();
});</code></pre>

<h3 id="sTARTTLS">STARTTLS <a href="#sTARTTLS">#</a></h3>

<p>In the v0.4 branch no function exists for starting a TLS session on an
already existing TCP connection.  This is possible it just requires a bit of
work. The technique is to use <code>tls.createSecurePair()</code> which returns two
streams: an encrypted stream and a cleartext stream. The encrypted stream is
then piped to the socket, the cleartext stream is what the user interacts with
thereafter.</p>

<p><a href="http://gist.github.com/848444">Here is some code that does it.</a></p>

<h3 id="nPN_and_SNI">NPN and SNI <a href="#nPN_and_SNI">#</a></h3>

<p>NPN (Next Protocol Negotiation) and SNI (Server Name Indication) are TLS
handshake extensions allowing you:</p>

<ul><li>NPN - to use one TLS server for multiple protocols (HTTP, SPDY)</li><li>SNI - to use one TLS server for multiple hostnames with different SSL
certificates.</li></ul>

<h3 id="pair_tls.createSecurePair">pair = tls.createSecurePair([credentials], [isServer], [requestCert], [rejectUnauthorized]) <a href="#pair_tls.createSecurePair">#</a></h3>

<p>Creates a new secure pair object with two streams, one of which reads/writes
encrypted data, and one reads/writes cleartext data.
Generally the encrypted one is piped to/from an incoming encrypted data stream,
and the cleartext one is used as a replacement for the initial encrypted stream.</p>

<ul><li><p><code>credentials</code>: A credentials object from crypto.createCredentials( ... )</p></li><li><p><code>isServer</code>: A boolean indicating whether this tls connection should be
opened as a server or a client.</p></li><li><p><code>requestCert</code>: A boolean indicating whether a server should request a
certificate from a connecting client. Only applies to server connections.</p></li><li><p><code>rejectUnauthorized</code>: A boolean indicating whether a server should
automatically reject clients with invalid certificates. Only applies to
servers with <code>requestCert</code> enabled.</p></li></ul>

<p><code>tls.createSecurePair()</code> returns a SecurePair object with
<a href="#tls.CleartextStream">cleartext</a> and <code>encrypted</code> stream properties.</p>

<h4 id="event_secure_">Event: 'secure' <a href="#event_secure_">#</a></h4>

<p>The event is emitted from the SecurePair once the pair has successfully
established a secure connection.</p>

<p>Similarly to the checking for the server 'secureConnection' event,
pair.cleartext.authorized should be checked to confirm whether the certificate
used properly authorized.</p>

<h3 id="tls.Server">tls.Server <a href="#tls.Server">#</a></h3>

<p>This class is a subclass of <code>net.Server</code> and has the same methods on it.
Instead of accepting just raw TCP connections, this accepts encrypted
connections using TLS or SSL.</p>

<h4 id="event_secureConnection_">Event: 'secureConnection' <a href="#event_secureConnection_">#</a></h4>

<p><code>function (cleartextStream) {}</code></p>

<p>This event is emitted after a new connection has been successfully
handshaked. The argument is a instance of
<a href="#tls.CleartextStream">CleartextStream</a>. It has all the common stream methods
and events.</p>

<p><code>cleartextStream.authorized</code> is a boolean value which indicates if the
client has verified by one of the supplied certificate authorities for the
server. If <code>cleartextStream.authorized</code> is false, then
<code>cleartextStream.authorizationError</code> is set to describe how authorization
failed. Implied but worth mentioning: depending on the settings of the TLS
server, you unauthorized connections may be accepted.
<code>cleartextStream.npnProtocol</code> is a string containing selected NPN protocol.
<code>cleartextStream.servername</code> is a string containing servername requested with
SNI.</p>

<h3 id="event_clientError_">Event: 'clientError' <a href="#event_clientError_">#</a></h3>

<p><code>function (exception) { }</code></p>

<p>When a client connection emits an 'error' event before secure connection is
established - it will be forwarded here.</p>

<h4 id="server.listen">server.listen(port, [host], [callback]) <a href="#server.listen">#</a></h4>

<p>Begin accepting connections on the specified <code>port</code> and <code>host</code>.  If the
<code>host</code> is omitted, the server will accept connections directed to any
IPv4 address (<code>INADDR_ANY</code>).</p>

<p>This function is asynchronous. The last parameter <code>callback</code> will be called
when the server has been bound.</p>

<p>See <code>net.Server</code> for more information.</p>

<h4 id="server.close">server.close() <a href="#server.close">#</a></h4>

<p>Stops the server from accepting new connections. This function is
asynchronous, the server is finally closed when the server emits a <code>'close'</code>
event.</p>

<h4 id="server.address">server.address() <a href="#server.address">#</a></h4>

<p>Returns the bound address and port of the server as reported by the operating
system.
See <a href="net.html#server.address">net.Server.address()</a> for more information.</p>

<h4 id="server.addContext">server.addContext(hostname, credentials) <a href="#server.addContext">#</a></h4>

<p>Add secure context that will be used if client request's SNI hostname is
matching passed <code>hostname</code> (wildcards can be used). <code>credentials</code> can contain
<code>key</code>, <code>cert</code> and <code>ca</code>.</p>

<h4 id="server.maxConnections">server.maxConnections <a href="#server.maxConnections">#</a></h4>

<p>Set this property to reject connections when the server's connection count
gets high.</p>

<h4 id="server.connections">server.connections <a href="#server.connections">#</a></h4>

<p>The number of concurrent connections on the server.</p>

<h3 id="tls.CleartextStream">tls.CleartextStream <a href="#tls.CleartextStream">#</a></h3>

<p>This is a stream on top of the <em>Encrypted</em> stream that makes it possible to
read/write an encrypted data as a cleartext data.</p>

<p>This instance implements a duplex <a href="streams.html#streams">Stream</a> interfaces.
It has all the common stream methods and events.</p>

<h4 id="event_secureConnect_">Event: 'secureConnect' <a href="#event_secureConnect_">#</a></h4>

<p><code>function () {}</code></p>

<p>This event is emitted after a new connection has been successfully handshaked. 
The listener will be called no matter if the server's certificate was
authorized or not. It is up to the user to test <code>cleartextStream.authorized</code>
to see if the server certificate was signed by one of the specified CAs.
If <code>cleartextStream.authorized === false</code> then the error can be found in
<code>cleartextStream.authorizationError</code>. Also if NPN was used - you can check
<code>cleartextStream.npnProtocol</code> for negotiated protocol.</p>

<h4 id="cleartextStream.authorized">cleartextStream.authorized <a href="#cleartextStream.authorized">#</a></h4>

<p>A boolean that is <code>true</code> if the peer certificate was signed by one of the
specified CAs, otherwise <code>false</code></p>

<h4 id="cleartextStream.authorizationError">cleartextStream.authorizationError <a href="#cleartextStream.authorizationError">#</a></h4>

<p>The reason why the peer's certificate has not been verified. This property
becomes available only when <code>cleartextStream.authorized === false</code>.</p>

<h4 id="cleartextStream.getPeerCertificate">cleartextStream.getPeerCertificate() <a href="#cleartextStream.getPeerCertificate">#</a></h4>

<p>Returns an object representing the peer's certificate. The returned object has
some properties corresponding to the field of the certificate.</p>

<p>Example:</p>

<pre><code>{ subject: 
   { C: 'UK',
     ST: 'Acknack Ltd',
     L: 'Rhys Jones',
     O: 'node.js',
     OU: 'Test TLS Certificate',
     CN: 'localhost' },
  issuer: 
   { C: 'UK',
     ST: 'Acknack Ltd',
     L: 'Rhys Jones',
     O: 'node.js',
     OU: 'Test TLS Certificate',
     CN: 'localhost' },
  valid_from: 'Nov 11 09:52:22 2009 GMT',
  valid_to: 'Nov  6 09:52:22 2029 GMT',
  fingerprint: '2A:7A:C2:DD:E5:F9:CC:53:72:35:99:7A:02:5A:71:38:52:EC:8A:DF' }</code></pre>

<p>If the peer does not provide a certificate, it returns <code>null</code> or an empty
object.</p>

<h4 id="cleartextStream.address">cleartextStream.address() <a href="#cleartextStream.address">#</a></h4>

<p>Returns the bound address and port of the underlying socket as reported by the
operating system. Returns an object with two properties, e.g.
<code>{"address":"192.168.57.1", "port":62053}</code></p>

<h4 id="cleartextStream.remoteAddress">cleartextStream.remoteAddress <a href="#cleartextStream.remoteAddress">#</a></h4>

<p>The string representation of the remote IP address. For example,
<code>'74.125.127.100'</code> or <code>'2001:4860:a005::68'</code>.</p>

<h4 id="cleartextStream.remotePort">cleartextStream.remotePort <a href="#cleartextStream.remotePort">#</a></h4>

<p>The numeric representation of the remote port. For example, <code>443</code>.</p>

<h2 id="file_System">File System</h2>

<p>File I/O is provided by simple wrappers around standard POSIX functions.  To
use this module do <code>require('fs')</code>. All the methods have asynchronous and
synchronous forms.</p>

<p>The asynchronous form always take a completion callback as its last argument.
The arguments passed to the completion callback depend on the method, but the
first argument is always reserved for an exception. If the operation was
completed successfully, then the first argument will be <code>null</code> or <code>undefined</code>.</p>

<p>When using the synchronous form any exceptions are immediately thrown.
You can use try/catch to handle exceptions or allow them to bubble up.</p>

<p>Here is an example of the asynchronous version:</p>

<pre><code>var fs = require('fs');

fs.unlink('/tmp/hello', function (err) {
  if (err) throw err;
  console.log('successfully deleted /tmp/hello');
});</code></pre>

<p>Here is the synchronous version:</p>

<pre><code>var fs = require('fs');

fs.unlinkSync('/tmp/hello')
console.log('successfully deleted /tmp/hello');</code></pre>

<p>With the asynchronous methods there is no guaranteed ordering. So the
following is prone to error:</p>

<pre><code>fs.rename('/tmp/hello', '/tmp/world', function (err) {
  if (err) throw err;
  console.log('renamed complete');
});
fs.stat('/tmp/world', function (err, stats) {
  if (err) throw err;
  console.log('stats: ' + JSON.stringify(stats));
});</code></pre>

<p>It could be that <code>fs.stat</code> is executed before <code>fs.rename</code>.
The correct way to do this is to chain the callbacks.</p>

<pre><code>fs.rename('/tmp/hello', '/tmp/world', function (err) {
  if (err) throw err;
  fs.stat('/tmp/world', function (err, stats) {
    if (err) throw err;
    console.log('stats: ' + JSON.stringify(stats));
  });
});</code></pre>

<p>In busy processes, the programmer is <em>strongly encouraged</em> to use the
asynchronous versions of these calls. The synchronous versions will block
the entire process until they complete--halting all connections.</p>

<p>Relative path to filename can be used, remember however that this path will be relative
to <code>process.cwd()</code>.</p>

<h3 id="fs.rename">fs.rename(path1, path2, [callback]) <a href="#fs.rename">#</a></h3>

<p>Asynchronous rename(2). No arguments other than a possible exception are given
to the completion callback.</p>

<h3 id="fs.renameSync">fs.renameSync(path1, path2) <a href="#fs.renameSync">#</a></h3>

<p>Synchronous rename(2).</p>

<h3 id="fs.truncate">fs.truncate(fd, len, [callback]) <a href="#fs.truncate">#</a></h3>

<p>Asynchronous ftruncate(2). No arguments other than a possible exception are
given to the completion callback.</p>

<h3 id="fs.truncateSync">fs.truncateSync(fd, len) <a href="#fs.truncateSync">#</a></h3>

<p>Synchronous ftruncate(2).</p>

<h3 id="fs.chown">fs.chown(path, uid, gid, [callback]) <a href="#fs.chown">#</a></h3>

<p>Asynchronous chown(2). No arguments other than a possible exception are given
to the completion callback.</p>

<h3 id="fs.chownSync">fs.chownSync(path, uid, gid) <a href="#fs.chownSync">#</a></h3>

<p>Synchronous chown(2).</p>

<h3 id="fs.fchown">fs.fchown(fd, uid, gid, [callback]) <a href="#fs.fchown">#</a></h3>

<p>Asynchronous fchown(2). No arguments other than a possible exception are given
to the completion callback.</p>

<h3 id="fs.fchownSync">fs.fchownSync(fd, uid, gid) <a href="#fs.fchownSync">#</a></h3>

<p>Synchronous fchown(2).</p>

<h3 id="fs.lchown">fs.lchown(path, uid, gid, [callback]) <a href="#fs.lchown">#</a></h3>

<p>Asynchronous lchown(2). No arguments other than a possible exception are given
to the completion callback.</p>

<h3 id="fs.lchownSync">fs.lchownSync(path, uid, gid) <a href="#fs.lchownSync">#</a></h3>

<p>Synchronous lchown(2).</p>

<h3 id="fs.chmod">fs.chmod(path, mode, [callback]) <a href="#fs.chmod">#</a></h3>

<p>Asynchronous chmod(2). No arguments other than a possible exception are given
to the completion callback.</p>

<h3 id="fs.chmodSync">fs.chmodSync(path, mode) <a href="#fs.chmodSync">#</a></h3>

<p>Synchronous chmod(2).</p>

<h3 id="fs.fchmod">fs.fchmod(fd, mode, [callback]) <a href="#fs.fchmod">#</a></h3>

<p>Asynchronous fchmod(2). No arguments other than a possible exception
are given to the completion callback.</p>

<h3 id="fs.fchmodSync">fs.fchmodSync(fd, mode) <a href="#fs.fchmodSync">#</a></h3>

<p>Synchronous fchmod(2).</p>

<h3 id="fs.lchmod">fs.lchmod(path, mode, [callback]) <a href="#fs.lchmod">#</a></h3>

<p>Asynchronous lchmod(2). No arguments other than a possible exception
are given to the completion callback.</p>

<h3 id="fs.lchmodSync">fs.lchmodSync(path, mode) <a href="#fs.lchmodSync">#</a></h3>

<p>Synchronous lchmod(2).</p>

<h3 id="fs.stat">fs.stat(path, [callback]) <a href="#fs.stat">#</a></h3>

<p>Asynchronous stat(2). The callback gets two arguments <code>(err, stats)</code> where
<code>stats</code> is a <a href="#fs.Stats">fs.Stats</a> object.  See the <a href="#fs.Stats">fs.Stats</a>
section below for more information.</p>

<h3 id="fs.lstat">fs.lstat(path, [callback]) <a href="#fs.lstat">#</a></h3>

<p>Asynchronous lstat(2). The callback gets two arguments <code>(err, stats)</code> where
<code>stats</code> is a <code>fs.Stats</code> object. <code>lstat()</code> is identical to <code>stat()</code>, except that if
<code>path</code> is a symbolic link, then the link itself is stat-ed, not the file that it
refers to.</p>

<h3 id="fs.fstat">fs.fstat(fd, [callback]) <a href="#fs.fstat">#</a></h3>

<p>Asynchronous fstat(2). The callback gets two arguments <code>(err, stats)</code> where
<code>stats</code> is a <code>fs.Stats</code> object. <code>fstat()</code> is identical to <code>stat()</code>, except that
the file to be stat-ed is specified by the file descriptor <code>fd</code>.</p>

<h3 id="fs.statSync">fs.statSync(path) <a href="#fs.statSync">#</a></h3>

<p>Synchronous stat(2). Returns an instance of <code>fs.Stats</code>.</p>

<h3 id="fs.lstatSync">fs.lstatSync(path) <a href="#fs.lstatSync">#</a></h3>

<p>Synchronous lstat(2). Returns an instance of <code>fs.Stats</code>.</p>

<h3 id="fs.fstatSync">fs.fstatSync(fd) <a href="#fs.fstatSync">#</a></h3>

<p>Synchronous fstat(2). Returns an instance of <code>fs.Stats</code>.</p>

<h3 id="fs.link">fs.link(srcpath, dstpath, [callback]) <a href="#fs.link">#</a></h3>

<p>Asynchronous link(2). No arguments other than a possible exception are given to
the completion callback.</p>

<h3 id="fs.linkSync">fs.linkSync(srcpath, dstpath) <a href="#fs.linkSync">#</a></h3>

<p>Synchronous link(2).</p>

<h3 id="fs.symlink">fs.symlink(linkdata, path, [type], [callback]) <a href="#fs.symlink">#</a></h3>

<p>Asynchronous symlink(2). No arguments other than a possible exception are given
to the completion callback.
<code>type</code> argument can be either <code>'dir'</code> or <code>'file'</code> (default is <code>'file'</code>).  It is only 
used on Windows (ignored on other platforms).</p>

<h3 id="fs.symlinkSync">fs.symlinkSync(linkdata, path, [type]) <a href="#fs.symlinkSync">#</a></h3>

<p>Synchronous symlink(2).</p>

<h3 id="fs.readlink">fs.readlink(path, [callback]) <a href="#fs.readlink">#</a></h3>

<p>Asynchronous readlink(2). The callback gets two arguments <code>(err,
linkString)</code>.</p>

<h3 id="fs.readlinkSync">fs.readlinkSync(path) <a href="#fs.readlinkSync">#</a></h3>

<p>Synchronous readlink(2). Returns the symbolic link's string value.</p>

<h3 id="fs.realpath">fs.realpath(path, [callback]) <a href="#fs.realpath">#</a></h3>

<p>Asynchronous realpath(2).  The callback gets two arguments <code>(err,
resolvedPath)</code>.  May use <code>process.cwd</code> to resolve relative paths.</p>

<h3 id="fs.realpathSync">fs.realpathSync(path) <a href="#fs.realpathSync">#</a></h3>

<p>Synchronous realpath(2). Returns the resolved path.</p>

<h3 id="fs.unlink">fs.unlink(path, [callback]) <a href="#fs.unlink">#</a></h3>

<p>Asynchronous unlink(2). No arguments other than a possible exception are given
to the completion callback.</p>

<h3 id="fs.unlinkSync">fs.unlinkSync(path) <a href="#fs.unlinkSync">#</a></h3>

<p>Synchronous unlink(2).</p>

<h3 id="fs.rmdir">fs.rmdir(path, [callback]) <a href="#fs.rmdir">#</a></h3>

<p>Asynchronous rmdir(2). No arguments other than a possible exception are given
to the completion callback.</p>

<h3 id="fs.rmdirSync">fs.rmdirSync(path) <a href="#fs.rmdirSync">#</a></h3>

<p>Synchronous rmdir(2).</p>

<h3 id="fs.mkdir">fs.mkdir(path, [mode], [callback]) <a href="#fs.mkdir">#</a></h3>

<p>Asynchronous mkdir(2). No arguments other than a possible exception are given
to the completion callback. <code>mode</code> defaults to <code>0777</code>.</p>

<h3 id="fs.mkdirSync">fs.mkdirSync(path, [mode]) <a href="#fs.mkdirSync">#</a></h3>

<p>Synchronous mkdir(2).</p>

<h3 id="fs.readdir">fs.readdir(path, [callback]) <a href="#fs.readdir">#</a></h3>

<p>Asynchronous readdir(3).  Reads the contents of a directory.
The callback gets two arguments <code>(err, files)</code> where <code>files</code> is an array of
the names of the files in the directory excluding <code>'.'</code> and <code>'..'</code>.</p>

<h3 id="fs.readdirSync">fs.readdirSync(path) <a href="#fs.readdirSync">#</a></h3>

<p>Synchronous readdir(3). Returns an array of filenames excluding <code>'.'</code> and
<code>'..'</code>.</p>

<h3 id="fs.close">fs.close(fd, [callback]) <a href="#fs.close">#</a></h3>

<p>Asynchronous close(2).  No arguments other than a possible exception are given
to the completion callback.</p>

<h3 id="fs.closeSync">fs.closeSync(fd) <a href="#fs.closeSync">#</a></h3>

<p>Synchronous close(2).</p>

<h3 id="fs.open">fs.open(path, flags, [mode], [callback]) <a href="#fs.open">#</a></h3>

<p>Asynchronous file open. See open(2). <code>flags</code> can be:</p>

<ul><li><p><code>'r'</code> - Open file for reading.
An exception occurs if the file does not exist.</p></li><li><p><code>'r+'</code> - Open file for reading and writing.
An exception occurs if the file does not exist.</p></li><li><p><code>'w'</code> - Open file for writing.
The file is created (if it does not exist) or truncated (if it exists).</p></li><li><p><code>'w+'</code> - Open file for reading and writing.
The file is created (if it does not exist) or truncated (if it exists).</p></li><li><p><code>'a'</code> - Open file for appending.
The file is created if it does not exist.</p></li><li><p><code>'a+'</code> - Open file for reading and appending.
The file is created if it does not exist.</p></li></ul>

<p><code>mode</code> defaults to <code>0666</code>. The callback gets two arguments <code>(err, fd)</code>.</p>

<h3 id="fs.openSync">fs.openSync(path, flags, [mode]) <a href="#fs.openSync">#</a></h3>

<p>Synchronous open(2).</p>

<h3 id="fs.utimes">fs.utimes(path, atime, mtime, [callback]) <a href="#fs.utimes">#</a></h3>

<h3 id="fs.utimesSync">fs.utimesSync(path, atime, mtime) <a href="#fs.utimesSync">#</a></h3>

<p>Change file timestamps of the file referenced by the supplied path.</p>

<h3 id="fs.futimes">fs.futimes(fd, atime, mtime, [callback]) <a href="#fs.futimes">#</a></h3>

<h3 id="fs.futimesSync">fs.futimesSync(fd, atime, mtime) <a href="#fs.futimesSync">#</a></h3>

<p>Change the file timestamps of a file referenced by the supplied file
descriptor.</p>

<h3 id="fs.fsync">fs.fsync(fd, [callback]) <a href="#fs.fsync">#</a></h3>

<p>Asynchronous fsync(2). No arguments other than a possible exception are given
to the completion callback.</p>

<h3 id="fs.fsyncSync">fs.fsyncSync(fd) <a href="#fs.fsyncSync">#</a></h3>

<p>Synchronous fsync(2).</p>

<h3 id="fs.write">fs.write(fd, buffer, offset, length, position, [callback]) <a href="#fs.write">#</a></h3>

<p>Write <code>buffer</code> to the file specified by <code>fd</code>.</p>

<p><code>offset</code> and <code>length</code> determine the part of the buffer to be written.</p>

<p><code>position</code> refers to the offset from the beginning of the file where this data
should be written. If <code>position</code> is <code>null</code>, the data will be written at the
current position.
See pwrite(2).</p>

<p>The callback will be given three arguments <code>(err, written, buffer)</code> where <code>written</code>
specifies how many <em>bytes</em> were written from <code>buffer</code>.</p>

<p>Note that it is unsafe to use <code>fs.write</code> multiple times on the same file
without waiting for the callback. For this scenario,
<code>fs.createWriteStream</code> is strongly recommended.</p>

<h3 id="fs.writeSync">fs.writeSync(fd, buffer, offset, length, position) <a href="#fs.writeSync">#</a></h3>

<p>Synchronous version of buffer-based <code>fs.write()</code>. Returns the number of bytes
written.</p>

<h3 id="fs.writeSync">fs.writeSync(fd, str, position, [encoding]) <a href="#fs.writeSync">#</a></h3>

<p>Synchronous version of string-based <code>fs.write()</code>. <code>encoding</code> defaults to
<code>'utf8'</code>. Returns the number of <em>bytes</em> written.</p>

<h3 id="fs.read">fs.read(fd, buffer, offset, length, position, [callback]) <a href="#fs.read">#</a></h3>

<p>Read data from the file specified by <code>fd</code>.</p>

<p><code>buffer</code> is the buffer that the data will be written to.</p>

<p><code>offset</code> is offset within the buffer where writing will start.</p>

<p><code>length</code> is an integer specifying the number of bytes to read.</p>

<p><code>position</code> is an integer specifying where to begin reading from in the file.
If <code>position</code> is <code>null</code>, data will be read from the current file position.</p>

<p>The callback is given the three arguments, <code>(err, bytesRead, buffer)</code>.</p>

<h3 id="fs.readSync">fs.readSync(fd, buffer, offset, length, position) <a href="#fs.readSync">#</a></h3>

<p>Synchronous version of buffer-based <code>fs.read</code>. Returns the number of
<code>bytesRead</code>.</p>

<h3 id="fs.readSync">fs.readSync(fd, length, position, encoding) <a href="#fs.readSync">#</a></h3>

<p>Synchronous version of string-based <code>fs.read</code>. Returns the number of
<code>bytesRead</code>.</p>

<h3 id="fs.readFile">fs.readFile(filename, [encoding], [callback]) <a href="#fs.readFile">#</a></h3>

<p>Asynchronously reads the entire contents of a file. Example:</p>

<pre><code>fs.readFile('/etc/passwd', function (err, data) {
  if (err) throw err;
  console.log(data);
});</code></pre>

<p>The callback is passed two arguments <code>(err, data)</code>, where <code>data</code> is the
contents of the file.</p>

<p>If no encoding is specified, then the raw buffer is returned.</p>

<h3 id="fs.readFileSync">fs.readFileSync(filename, [encoding]) <a href="#fs.readFileSync">#</a></h3>

<p>Synchronous version of <code>fs.readFile</code>. Returns the contents of the <code>filename</code>.</p>

<p>If <code>encoding</code> is specified then this function returns a string. Otherwise it
returns a buffer.</p>

<h3 id="fs.writeFile">fs.writeFile(filename, data, [encoding], [callback]) <a href="#fs.writeFile">#</a></h3>

<p>Asynchronously writes data to a file, replacing the file if it already exists.
<code>data</code> can be a string or a buffer. The <code>encoding</code> argument is ignored if
<code>data</code> is a buffer. It defaults to <code>'utf8'</code>.</p>

<p>Example:</p>

<pre><code>fs.writeFile('message.txt', 'Hello Node', function (err) {
  if (err) throw err;
  console.log('It\'s saved!');
});</code></pre>

<h3 id="fs.writeFileSync">fs.writeFileSync(filename, data, [encoding]) <a href="#fs.writeFileSync">#</a></h3>

<p>The synchronous version of <code>fs.writeFile</code>.</p>

<h3 id="fs.watchFile">fs.watchFile(filename, [options], listener) <a href="#fs.watchFile">#</a></h3>

<p>Watch for changes on <code>filename</code>. The callback <code>listener</code> will be called each
time the file is accessed.</p>

<p>The second argument is optional. The <code>options</code> if provided should be an object
containing two members a boolean, <code>persistent</code>, and <code>interval</code>. <code>persistent</code>
indicates whether the process should continue to run as long as files are
being watched. <code>interval</code> indicates how often the target should be polled,
in milliseconds. (On Linux systems with inotify, <code>interval</code> is ignored.) The
default is <code>{ persistent: true, interval: 0 }</code>.</p>

<p>The <code>listener</code> gets two arguments the current stat object and the previous
stat object:</p>

<pre><code>fs.watchFile('message.text', function (curr, prev) {
  console.log('the current mtime is: ' + curr.mtime);
  console.log('the previous mtime was: ' + prev.mtime);
});</code></pre>

<p>These stat objects are instances of <code>fs.Stat</code>.</p>

<p>If you want to be notified when the file was modified, not just accessed
you need to compare <code>curr.mtime</code> and <code>prev.mtime</code>.</p>

<h3 id="fs.unwatchFile">fs.unwatchFile(filename) <a href="#fs.unwatchFile">#</a></h3>

<p>Stop watching for changes on <code>filename</code>.</p>

<h3 id="fs.watch">fs.watch(filename, [options], listener) <a href="#fs.watch">#</a></h3>

<p>Watch for changes on <code>filename</code>, where <code>filename</code> is either a file or a
directory.  The returned object is <a href="#fs.FSWatcher">fs.FSWatcher</a>.</p>

<p>The second argument is optional. The <code>options</code> if provided should be an object
containing a boolean member <code>persistent</code>, which indicates whether the process
should continue to run as long as files are being watched. The default is
<code>{ persistent: true }</code>.</p>

<p>The listener callback gets two arguments <code>(event, filename)</code>.  <code>event</code> is either
'rename' or 'change', and <code>filename</code> is the name of the file which triggered
the event.</p>

<p><strong>*Warning:</strong>*
Providing <code>filename</code> argument in the callback is not supported
on every platform (currently it's only supported on Linux and Windows).  Even
on supported platforms <code>filename</code> is not always guaranteed to be provided.
Therefore, don't assume that <code>filename</code> argument is always provided in the
callback, and have some fallback logic if it is null.</p>

<pre><code>fs.watch('somedir', function (event, filename) {
  console.log('event is: ' + event);
  if (filename) {
    console.log('filename provided: ' + filename);
  } else {
    console.log('filename not provided');
  }
});</code></pre>

<h2 id="fs.Stats">fs.Stats</h2>

<p>Objects returned from <code>fs.stat()</code>, <code>fs.lstat()</code> and <code>fs.fstat()</code> and their
synchronous counterparts are of this type.</p>

<ul><li><code>stats.isFile()</code></li><li><code>stats.isDirectory()</code></li><li><code>stats.isBlockDevice()</code></li><li><code>stats.isCharacterDevice()</code></li><li><code>stats.isSymbolicLink()</code> (only valid with  <code>fs.lstat()</code>)</li><li><code>stats.isFIFO()</code></li><li><code>stats.isSocket()</code></li></ul>

<p>For a regular file <code>util.inspect(stats)</code> would return a string very
similar to this:</p>

<pre><code>{ dev: 2114,
  ino: 48064969,
  mode: 33188,
  nlink: 1,
  uid: 85,
  gid: 100,
  rdev: 0,
  size: 527,
  blksize: 4096,
  blocks: 8,
  atime: Mon, 10 Oct 2011 23:24:11 GMT,
  mtime: Mon, 10 Oct 2011 23:24:11 GMT,
  ctime: Mon, 10 Oct 2011 23:24:11 GMT }</code></pre>

<p>Please note that <code>atime</code>, <code>mtime</code> and <code>ctime</code> are instances
of <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">Date</a> object and to compare the values of
these objects you should use appropriate methods. For most
general uses <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/getTime">getTime()</a> will return
the number of milliseconds elapsed since <em>1 January 1970
00:00:00 UTC</em> and this integer should be sufficient for
any comparison, however there additional methods which can
be used for displaying fuzzy information. More details can
be found in the <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">MDN JavaScript Reference</a> page.</p>

<h2 id="fs.ReadStream">fs.ReadStream</h2>

<p><code>ReadStream</code> is a <a href="streams.html#readable_Stream">Readable Stream</a>.</p>

<h3 id="event_open_">Event: 'open' <a href="#event_open_">#</a></h3>

<p><code>function (fd) { }</code></p>

<p> <code>fd</code> is the file descriptor used by the ReadStream.</p>

<h3 id="fs.createReadStream">fs.createReadStream(path, [options]) <a href="#fs.createReadStream">#</a></h3>

<p>Returns a new ReadStream object (See <code>Readable Stream</code>).</p>

<p><code>options</code> is an object with the following defaults:</p>

<pre><code>{ flags: 'r',
  encoding: null,
  fd: null,
  mode: 0666,
  bufferSize: 64 * 1024
}</code></pre>

<p><code>options</code> can include <code>start</code> and <code>end</code> values to read a range of bytes from
the file instead of the entire file.  Both <code>start</code> and <code>end</code> are inclusive and
start at 0.</p>

<p>An example to read the last 10 bytes of a file which is 100 bytes long:</p>

<pre><code>fs.createReadStream('sample.txt', {start: 90, end: 99});</code></pre>

<h2 id="fs.WriteStream">fs.WriteStream</h2>

<p><code>WriteStream</code> is a <a href="streams.html#writable_Stream">Writable Stream</a>.</p>

<h3 id="event_open_">Event: 'open' <a href="#event_open_">#</a></h3>

<p><code>function (fd) { }</code></p>

<p> <code>fd</code> is the file descriptor used by the WriteStream.</p>

<h3 id="file.bytesWritten">file.bytesWritten <a href="#file.bytesWritten">#</a></h3>

<p>The number of bytes written so far. Does not include data that is still queued
for writing.</p>

<h3 id="fs.createWriteStream">fs.createWriteStream(path, [options]) <a href="#fs.createWriteStream">#</a></h3>

<p>Returns a new WriteStream object (See <code>Writable Stream</code>).</p>

<p><code>options</code> is an object with the following defaults:</p>

<pre><code>{ flags: 'w',
  encoding: null,
  mode: 0666 }</code></pre>

<p><code>options</code> may also include a <code>start</code> option to allow writing data at
some position past the beginning of the file.  Modifying a file rather
than replacing it may require a <code>flags</code> mode of <code>r+</code> rather than the
default mode <code>w</code>.</p>

<h2 id="fs.FSWatcher">fs.FSWatcher</h2>

<p>Objects returned from <code>fs.watch()</code> are of this type.</p>

<h4 id="watcher.close">watcher.close() <a href="#watcher.close">#</a></h4>

<p>Stop watching for changes on the given <code>fs.FSWatcher</code>.</p>

<h4 id="event_change_">Event: 'change' <a href="#event_change_">#</a></h4>

<p><code>function (event, filename) {}</code></p>

<p>Emitted when something changes in a watched directory or file.
See more details in <a href="#fs.watch">fs.watch</a>.</p>

<h4 id="event_error_">Event: 'error' <a href="#event_error_">#</a></h4>

<p><code>function (exception) {}</code></p>

<p>Emitted when an error occurs.</p>

<h2 id="path">Path</h2>

<p>This module contains utilities for handling and transforming file
paths.  Almost all these methods perform only string transformations.
The file system is not consulted to check whether paths are valid.</p>

<p><code>path.exists</code> and <code>path.existsSync</code> are the exceptions, and should
logically be found in the fs module as they do access the file system.</p>

<p>Use <code>require('path')</code> to use this module.  The following methods are provided:</p>

<h3 id="path.normalize">path.normalize(p) <a href="#path.normalize">#</a></h3>

<p>Normalize a string path, taking care of <code>'..'</code> and <code>'.'</code> parts.</p>

<p>When multiple slashes are found, they're replaced by a single one;
when the path contains a trailing slash, it is preserved.
On windows backslashes are used. </p>

<p>Example:</p>

<pre><code>path.normalize('/foo/bar//baz/asdf/quux/..')
// returns
'/foo/bar/baz/asdf'</code></pre>

<h3 id="path.join">path.join([path1], [path2], [...]) <a href="#path.join">#</a></h3>

<p>Join all arguments together and normalize the resulting path.
Non-string arguments are ignored.</p>

<p>Example:</p>

<pre><code>path.join('/foo', 'bar', 'baz/asdf', 'quux', '..')
// returns
'/foo/bar/baz/asdf'

path.join('foo', {}, 'bar')
// returns
'foo/bar'</code></pre>

<h3 id="path.resolve">path.resolve([from ...], to) <a href="#path.resolve">#</a></h3>

<p>Resolves <code>to</code> to an absolute path.</p>

<p>If <code>to</code> isn't already absolute <code>from</code> arguments are prepended in right to left
order, until an absolute path is found. If after using all <code>from</code> paths still
no absolute path is found, the current working directory is used as well. The
resulting path is normalized, and trailing slashes are removed unless the path 
gets resolved to the root directory. Non-string arguments are ignored.</p>

<p>Another way to think of it is as a sequence of <code>cd</code> commands in a shell.</p>

<pre><code>path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile')</code></pre>

<p>Is similar to:</p>

<pre><code>cd foo/bar
cd /tmp/file/
cd ..
cd a/../subfile
pwd</code></pre>

<p>The difference is that the different paths don't need to exist and may also be
files.</p>

<p>Examples:</p>

<pre><code>path.resolve('/foo/bar', './baz')
// returns
'/foo/bar/baz'

path.resolve('/foo/bar', '/tmp/file/')
// returns
'/tmp/file'

path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')
// if currently in /home/myself/node, it returns
'/home/myself/node/wwwroot/static_files/gif/image.gif'</code></pre>

<h3 id="path.relative">path.relative(from, to) <a href="#path.relative">#</a></h3>

<p>Solve the relative path from <code>from</code> to <code>to</code>.</p>

<p>At times we have two absolute paths, and we need to derive the relative
path from one to the other.  This is actually the reverse transform of
<code>path.resolve</code>, which means we see that:</p>

<pre><code>path.resolve(from, path.relative(from, to)) == path.resolve(to)</code></pre>

<p>Examples:</p>

<pre><code>path.relative('C:\\orandea\\test\\aaa', 'C:\\orandea\\impl\\bbb')
// returns
'..\\..\\impl\\bbb'

path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')
// returns
'../../impl/bbb'</code></pre>

<h3 id="path.dirname">path.dirname(p) <a href="#path.dirname">#</a></h3>

<p>Return the directory name of a path.  Similar to the Unix <code>dirname</code> command.</p>

<p>Example:</p>

<pre><code>path.dirname('/foo/bar/baz/asdf/quux')
// returns
'/foo/bar/baz/asdf'</code></pre>

<h3 id="path.basename">path.basename(p, [ext]) <a href="#path.basename">#</a></h3>

<p>Return the last portion of a path.  Similar to the Unix <code>basename</code> command.</p>

<p>Example:</p>

<pre><code>path.basename('/foo/bar/baz/asdf/quux.html')
// returns
'quux.html'

path.basename('/foo/bar/baz/asdf/quux.html', '.html')
// returns
'quux'</code></pre>

<h3 id="path.extname">path.extname(p) <a href="#path.extname">#</a></h3>

<p>Return the extension of the path, from the last '.' to end of string
in the last portion of the path.  If there is no '.' in the last portion
of the path or the first character of it is '.', then it returns
an empty string.  Examples:</p>

<pre><code>path.extname('index.html')
// returns
'.html'

path.extname('index.')
// returns
'.'

path.extname('index')
// returns
''</code></pre>

<h3 id="path.exists">path.exists(p, [callback]) <a href="#path.exists">#</a></h3>

<p>Test whether or not the given path exists by checking with the file system.
Then call the <code>callback</code> argument with either true or false.  Example:</p>

<pre><code>path.exists('/etc/passwd', function (exists) {
  util.debug(exists ? "it's there" : "no passwd!");
});</code></pre>

<h3 id="path.existsSync">path.existsSync(p) <a href="#path.existsSync">#</a></h3>

<p>Synchronous version of <code>path.exists</code>.</p>

<h2 id="net">net</h2>

<p>The <code>net</code> module provides you with an asynchronous network wrapper. It contains
methods for creating both servers and clients (called streams). You can include
this module with <code>require('net');</code></p>

<h3 id="net.createServer">net.createServer([options], [connectionListener]) <a href="#net.createServer">#</a></h3>

<p>Creates a new TCP server. The <code>connectionListener</code> argument is
automatically set as a listener for the <a href="#event_connection_">'connection'</a>
event.</p>

<p><code>options</code> is an object with the following defaults:</p>

<pre><code>{ allowHalfOpen: false
}</code></pre>

<p>If <code>allowHalfOpen</code> is <code>true</code>, then the socket won't automatically send FIN
packet when the other end of the socket sends a FIN packet. The socket becomes
non-readable, but still writable. You should call the <code>end()</code> method explicitly.
See <a href="#event_end_">'end'</a> event for more information.</p>

<p>Here is an example of a echo server which listens for connections
on port 8124:</p>

<pre><code>var net = require('net');
var server = net.createServer(function(c) { //'connection' listener
  console.log('server connected');
  c.on('end', function() {
    console.log('server disconnected');
  });
  c.write('hello\r\n');
  c.pipe(c);
});
server.listen(8124, function() { //'listening' listener
  console.log('server bound');
});</code></pre>

<p>Test this by using <code>telnet</code>:</p>

<pre><code>telnet localhost 8124</code></pre>

<p>To listen on the socket <code>/tmp/echo.sock</code> the third line from the last would
just be changed to</p>

<pre><code>server.listen('/tmp/echo.sock', function() { //'listening' listener</code></pre>

<p>Use <code>nc</code> to connect to a UNIX domain socket server:</p>

<pre><code>nc -U /tmp/echo.sock</code></pre>

<h3 id="net.connect">net.connect(arguments...) <a href="#net.connect">#</a></h3>

<h3 id="net.createConnection">net.createConnection(arguments...) <a href="#net.createConnection">#</a></h3>

<p>Construct a new socket object and opens a socket to the given location. When
the socket is established the <a href="#event_connect_">'connect'</a> event will be
emitted.</p>

<p>The arguments for these methods change the type of connection:</p>

<ul><li><code>net.connect(port, [host], [connectListener])</code></li><li><p><code>net.createConnection(port, [host], [connectListener])</code></p><p>Creates a TCP connection to <code>port</code> on <code>host</code>. If <code>host</code> is omitted,
<code>'localhost'</code> will be assumed.</p></li><li><p><code>net.connect(path, [connectListener])</code></p></li><li><p><code>net.createConnection(path, [connectListener])</code></p><p>Creates unix socket connection to <code>path</code>.</p></li></ul>

<p>The <code>connectListener</code> parameter will be added as an listener for the
<a href="#event_connect_">'connect'</a> event.</p>

<p>Here is an example of a client of echo server as described previously:</p>

<pre><code>var net = require('net');
var client = net.connect(8124, function() { //'connect' listener
  console.log('client connected');
  client.write('world!\r\n');
});
client.on('data', function(data) {
  console.log(data.toString());
  client.end();
});
client.on('end', function() {
  console.log('client disconnected');
});</code></pre>

<p>To connect on the socket <code>/tmp/echo.sock</code> the second line would just be
changed to</p>

<pre><code>var client = net.connect('/tmp/echo.sock', function() { //'connect' listener</code></pre>

<hr />

<h3 id="net.Server">net.Server <a href="#net.Server">#</a></h3>

<p>This class is used to create a TCP or UNIX server.
A server is a <code>net.Socket</code> that can listen for new incoming connections.</p>

<h4 id="server.listen">server.listen(port, [host], [listeningListener]) <a href="#server.listen">#</a></h4>

<p>Begin accepting connections on the specified <code>port</code> and <code>host</code>.  If the
<code>host</code> is omitted, the server will accept connections directed to any
IPv4 address (<code>INADDR_ANY</code>). A port value of zero will assign a random port.</p>

<p>This function is asynchronous.  When the server has been bound,
<a href="#event_listening_">'listening'</a> event will be emitted.
the last parameter <code>listeningListener</code> will be added as an listener for the
<a href="#event_listening_">'listening'</a> event.</p>

<p>One issue some users run into is getting <code>EADDRINUSE</code> errors. This means that
another server is already running on the requested port. One way of handling this
would be to wait a second and then try again. This can be done with</p>

<pre><code>server.on('error', function (e) {
  if (e.code == 'EADDRINUSE') {
    console.log('Address in use, retrying...');
    setTimeout(function () {
      server.close();
      server.listen(PORT, HOST);
    }, 1000);
  }
});</code></pre>

<p>(Note: All sockets in Node set <code>SO_REUSEADDR</code> already)</p>

<h4 id="server.listen">server.listen(path, [listeningListener]) <a href="#server.listen">#</a></h4>

<p>Start a UNIX socket server listening for connections on the given <code>path</code>.</p>

<p>This function is asynchronous. The last parameter <code>listeningListener</code> will be
called when the server has been bound.
See also <a href="#event_listening_">'listening'</a> event.</p>

<h4 id="server.pause">server.pause(msecs) <a href="#server.pause">#</a></h4>

<p>Stop accepting connections for the given number of milliseconds (default is
one second).  This could be useful for throttling new connections against
DoS attacks or other oversubscription.</p>

<h4 id="server.close">server.close() <a href="#server.close">#</a></h4>

<p>Stops the server from accepting new connections. This function is
asynchronous, the server is finally closed when the server emits a <code>'close'</code>
event.</p>

<h4 id="server.address">server.address() <a href="#server.address">#</a></h4>

<p>Returns the bound address and port of the server as reported by the operating system.
Useful to find which port was assigned when giving getting an OS-assigned address.
Returns an object with two properties, e.g. <code>{"address":"127.0.0.1", "port":2121}</code></p>

<p>Example:</p>

<pre><code>var server = net.createServer(function (socket) {
  socket.end("goodbye\n");
});

// grab a random port.
server.listen(function() {
  address = server.address();
  console.log("opened server on %j", address);
});</code></pre>

<h4 id="server.maxConnections">server.maxConnections <a href="#server.maxConnections">#</a></h4>

<p>Set this property to reject connections when the server's connection count gets
high.</p>

<h4 id="server.connections">server.connections <a href="#server.connections">#</a></h4>

<p>The number of concurrent connections on the server.</p>

<p><code>net.Server</code> is an <code>EventEmitter</code> with the following events:</p>

<h4 id="event_listening_">Event: 'listening' <a href="#event_listening_">#</a></h4>

<p><code>function () {}</code></p>

<p>Emitted when the server has been bound after calling <code>server.listen</code>.</p>

<h4 id="event_connection_">Event: 'connection' <a href="#event_connection_">#</a></h4>

<p><code>function (socket) {}</code></p>

<p>Emitted when a new connection is made. <code>socket</code> is an instance of
<code>net.Socket</code>.</p>

<h4 id="event_close_">Event: 'close' <a href="#event_close_">#</a></h4>

<p><code>function () {}</code></p>

<p>Emitted when the server closes.</p>

<h4 id="event_error_">Event: 'error' <a href="#event_error_">#</a></h4>

<p><code>function (exception) {}</code></p>

<p>Emitted when an error occurs.  The <code>'close'</code> event will be called directly
following this event.  See example in discussion of <code>server.listen</code>.</p>

<hr />

<h3 id="net.Socket">net.Socket <a href="#net.Socket">#</a></h3>

<p>This object is an abstraction of a TCP or UNIX socket.  <code>net.Socket</code>
instances implement a duplex Stream interface.  They can be created by the
user and used as a client (with <code>connect()</code>) or they can be created by Node
and passed to the user through the <code>'connection'</code> event of a server.</p>

<h4 id="new_net.Socket">new net.Socket([options]) <a href="#new_net.Socket">#</a></h4>

<p>Construct a new socket object.</p>

<p><code>options</code> is an object with the following defaults:</p>

<pre><code>{ fd: null
  type: null
  allowHalfOpen: false
}</code></pre>

<p><code>fd</code> allows you to specify the existing file descriptor of socket. <code>type</code>
specified underlying protocol. It can be <code>'tcp4'</code>, <code>'tcp6'</code>, or <code>'unix'</code>.
About <code>allowHalfOpen</code>, refer to <code>createServer()</code> and <code>'end'</code> event.</p>

<h4 id="socket.connect">socket.connect(port, [host], [connectListener]) <a href="#socket.connect">#</a></h4>

<h4 id="socket.connect">socket.connect(path, [connectListener]) <a href="#socket.connect">#</a></h4>

<p>Opens the connection for a given socket. If <code>port</code> and <code>host</code> are given,
then the socket will be opened as a TCP socket, if <code>host</code> is omitted,
<code>localhost</code> will be assumed. If a <code>path</code> is given, the socket will be
opened as a unix socket to that path.</p>

<p>Normally this method is not needed, as <code>net.createConnection</code> opens the
socket. Use this only if you are implementing a custom Socket or if a
Socket is closed and you want to reuse it to connect to another server.</p>

<p>This function is asynchronous. When the <a href="#event_connect_">'connect'</a> event is
emitted the socket is established. If there is a problem connecting, the
<code>'connect'</code> event will not be emitted, the <code>'error'</code> event will be emitted with
the exception.</p>

<p>The <code>connectListener</code> parameter will be added as an listener for the
<a href="#event_connect_">'connect'</a> event.</p>

<h4 id="socket.bufferSize">socket.bufferSize <a href="#socket.bufferSize">#</a></h4>

<p><code>net.Socket</code> has the property that <code>socket.write()</code> always works. This is to
help users get up and running quickly. The computer cannot always keep up
with the amount of data that is written to a socket - the network connection
simply might be too slow. Node will internally queue up the data written to a
socket and send it out over the wire when it is possible. (Internally it is
polling on the socket's file descriptor for being writable).</p>

<p>The consequence of this internal buffering is that memory may grow. This
property shows the number of characters currently buffered to be written.
(Number of characters is approximately equal to the number of bytes to be
written, but the buffer may contain strings, and the strings are lazily
encoded, so the exact number of bytes is not known.)</p>

<p>Users who experience large or growing <code>bufferSize</code> should attempt to
"throttle" the data flows in their program with <code>pause()</code> and <code>resume()</code>.</p>

<h4 id="socket.setEncoding">socket.setEncoding([encoding]) <a href="#socket.setEncoding">#</a></h4>

<p>Sets the encoding (either <code>'ascii'</code>, <code>'utf8'</code>, or <code>'base64'</code>) for data that is
received. Defaults to <code>null</code>.</p>

<h4 id="socket.setSecure">socket.setSecure() <a href="#socket.setSecure">#</a></h4>

<p>This function has been removed in v0.3. It used to upgrade the connection to
SSL/TLS. See the <a href="tls.html#tLS_">TLS section</a> for the new API.</p>

<h4 id="socket.write">socket.write(data, [encoding], [callback]) <a href="#socket.write">#</a></h4>

<p>Sends data on the socket. The second parameter specifies the encoding in the
case of a string--it defaults to UTF8 encoding.</p>

<p>Returns <code>true</code> if the entire data was flushed successfully to the kernel
buffer. Returns <code>false</code> if all or part of the data was queued in user memory.
<code>'drain'</code> will be emitted when the buffer is again free.</p>

<p>The optional <code>callback</code> parameter will be executed when the data is finally
written out - this may not be immediately.</p>

<h4 id="socket.write">socket.write(data, [encoding], [callback]) <a href="#socket.write">#</a></h4>

<p>Write data with the optional encoding. The callback will be made when the
data is flushed to the kernel.</p>

<h4 id="socket.end">socket.end([data], [encoding]) <a href="#socket.end">#</a></h4>

<p>Half-closes the socket. i.e., it sends a FIN packet. It is possible the
server will still send some data.</p>

<p>If <code>data</code> is specified, it is equivalent to calling
<code>socket.write(data, encoding)</code> followed by <code>socket.end()</code>.</p>

<h4 id="socket.destroy">socket.destroy() <a href="#socket.destroy">#</a></h4>

<p>Ensures that no more I/O activity happens on this socket. Only necessary in
case of errors (parse error or so).</p>

<h4 id="socket.pause">socket.pause() <a href="#socket.pause">#</a></h4>

<p>Pauses the reading of data. That is, <code>'data'</code> events will not be emitted.
Useful to throttle back an upload.</p>

<h4 id="socket.resume">socket.resume() <a href="#socket.resume">#</a></h4>

<p>Resumes reading after a call to <code>pause()</code>.</p>

<h4 id="socket.setTimeout">socket.setTimeout(timeout, [callback]) <a href="#socket.setTimeout">#</a></h4>

<p>Sets the socket to timeout after <code>timeout</code> milliseconds of inactivity on
the socket. By default <code>net.Socket</code> do not have a timeout.</p>

<p>When an idle timeout is triggered the socket will receive a <code>'timeout'</code>
event but the connection will not be severed. The user must manually <code>end()</code>
or <code>destroy()</code> the socket.</p>

<p>If <code>timeout</code> is 0, then the existing idle timeout is disabled.</p>

<p>The optional <code>callback</code> parameter will be added as a one time listener for the
<code>'timeout'</code> event.</p>

<h4 id="socket.setNoDelay">socket.setNoDelay([noDelay]) <a href="#socket.setNoDelay">#</a></h4>

<p>Disables the Nagle algorithm. By default TCP connections use the Nagle
algorithm, they buffer data before sending it off. Setting <code>true</code> for
<code>noDelay</code> will immediately fire off data each time <code>socket.write()</code> is called.
<code>noDelay</code> defaults to <code>true</code>.</p>

<h4 id="socket.setKeepAlive">socket.setKeepAlive([enable], [initialDelay]) <a href="#socket.setKeepAlive">#</a></h4>

<p>Enable/disable keep-alive functionality, and optionally set the initial
delay before the first keepalive probe is sent on an idle socket.
<code>enable</code> defaults to <code>false</code>.</p>

<p>Set <code>initialDelay</code> (in milliseconds) to set the delay between the last
data packet received and the first keepalive probe. Setting 0 for
initialDelay will leave the value unchanged from the default
(or previous) setting. Defaults to <code>0</code>.</p>

<h4 id="socket.address">socket.address() <a href="#socket.address">#</a></h4>

<p>Returns the bound address and port of the socket as reported by the operating
system. Returns an object with two properties, e.g.
<code>{"address":"192.168.57.1", "port":62053}</code></p>

<h4 id="socket.remoteAddress">socket.remoteAddress <a href="#socket.remoteAddress">#</a></h4>

<p>The string representation of the remote IP address. For example,
<code>'74.125.127.100'</code> or <code>'2001:4860:a005::68'</code>.</p>

<h4 id="socket.remotePort">socket.remotePort <a href="#socket.remotePort">#</a></h4>

<p>The numeric representation of the remote port. For example,
<code>80</code> or <code>21</code>.</p>

<h4 id="socket.bytesRead">socket.bytesRead <a href="#socket.bytesRead">#</a></h4>

<p>The amount of received bytes.</p>

<h4 id="socket.bytesWritten">socket.bytesWritten <a href="#socket.bytesWritten">#</a></h4>

<p>The amount of bytes sent.</p>

<p><code>net.Socket</code> instances are EventEmitters with the following events:</p>

<h4 id="event_connect_">Event: 'connect' <a href="#event_connect_">#</a></h4>

<p><code>function () { }</code></p>

<p>Emitted when a socket connection is successfully established.
See <code>connect()</code>.</p>

<h4 id="event_data_">Event: 'data' <a href="#event_data_">#</a></h4>

<p><code>function (data) { }</code></p>

<p>Emitted when data is received.  The argument <code>data</code> will be a <code>Buffer</code> or
<code>String</code>.  Encoding of data is set by <code>socket.setEncoding()</code>.
(See the <a href="streams.html#readable_Stream">Readable Stream</a> section for more
information.)</p>

<h4 id="event_end_">Event: 'end' <a href="#event_end_">#</a></h4>

<p><code>function () { }</code></p>

<p>Emitted when the other end of the socket sends a FIN packet.</p>

<p>By default (<code>allowHalfOpen == false</code>) the socket will destroy its file
descriptor  once it has written out its pending write queue.  However, by
setting <code>allowHalfOpen == true</code> the socket will not automatically <code>end()</code>
its side allowing the user to write arbitrary amounts of data, with the
caveat that the user is required to <code>end()</code> their side now.</p>

<h4 id="event_timeout_">Event: 'timeout' <a href="#event_timeout_">#</a></h4>

<p><code>function () { }</code></p>

<p>Emitted if the socket times out from inactivity. This is only to notify that
the socket has been idle. The user must manually close the connection.</p>

<p>See also: <code>socket.setTimeout()</code></p>

<h4 id="event_drain_">Event: 'drain' <a href="#event_drain_">#</a></h4>

<p><code>function () { }</code></p>

<p>Emitted when the write buffer becomes empty. Can be used to throttle uploads.</p>

<p>See also: the return values of <code>socket.write()</code></p>

<h4 id="event_error_">Event: 'error' <a href="#event_error_">#</a></h4>

<p><code>function (exception) { }</code></p>

<p>Emitted when an error occurs.  The <code>'close'</code> event will be called directly
following this event.</p>

<h4 id="event_close_">Event: 'close' <a href="#event_close_">#</a></h4>

<p><code>function (had_error) { }</code></p>

<p>Emitted once the socket is fully closed. The argument <code>had_error</code> is a boolean
which says if the socket was closed due to a transmission error.</p>

<hr />

<h3 id="net.isIP">net.isIP <a href="#net.isIP">#</a></h3>

<h4 id="net.isIP">net.isIP(input) <a href="#net.isIP">#</a></h4>

<p>Tests if input is an IP address. Returns 0 for invalid strings,
returns 4 for IP version 4 addresses, and returns 6 for IP version 6 addresses.</p>

<h4 id="net.isIPv4">net.isIPv4(input) <a href="#net.isIPv4">#</a></h4>

<p>Returns true if input is a version 4 IP address, otherwise returns false.</p>

<h4 id="net.isIPv6">net.isIPv6(input) <a href="#net.isIPv6">#</a></h4>

<p>Returns true if input is a version 6 IP address, otherwise returns false.</p>

<h2 id="uDP_Datagram_Sockets">UDP / Datagram Sockets</h2>

<p>Datagram sockets are available through <code>require('dgram')</code>.</p>

<h3 id="event_message_">Event: 'message' <a href="#event_message_">#</a></h3>

<p><code>function (msg, rinfo) { }</code></p>

<p>Emitted when a new datagram is available on a socket.  <code>msg</code> is a <code>Buffer</code> and <code>rinfo</code> is
an object with the sender's address information and the number of bytes in the datagram.</p>

<h3 id="event_listening_">Event: 'listening' <a href="#event_listening_">#</a></h3>

<p><code>function () { }</code></p>

<p>Emitted when a socket starts listening for datagrams.  This happens as soon as UDP sockets
are created.</p>

<h3 id="event_close_">Event: 'close' <a href="#event_close_">#</a></h3>

<p><code>function () { }</code></p>

<p>Emitted when a socket is closed with <code>close()</code>.  No new <code>message</code> events will be emitted
on this socket.</p>

<h3 id="event_error_">Event: 'error' <a href="#event_error_">#</a></h3>

<p><code>function (exception) {}</code></p>

<p>Emitted when an error occurs.</p>

<hr />

<h3 id="dgram.createSocket">dgram.createSocket(type, [callback]) <a href="#dgram.createSocket">#</a></h3>

<p>Creates a datagram socket of the specified types.  Valid types are <code>udp4</code>
and <code>udp6</code>.</p>

<p>Takes an optional callback which is added as a listener for <code>message</code> events.</p>

<p>Call <code>socket.bind</code> if you want to receive datagrams. <code>socket.bind()</code> will bind
to the "all interfaces" address on a random port (it does the right thing for
both <code>udp4</code> and <code>udp6</code> sockets). You can then retrieve the address and port
with <code>socket.address().address</code> and <code>socket.address().port</code>.</p>

<h3 id="dgram.send">dgram.send(buf, offset, length, port, address, [callback]) <a href="#dgram.send">#</a></h3>

<p>For UDP sockets, the destination port and IP address must be specified.  A string
may be supplied for the <code>address</code> parameter, and it will be resolved with DNS.  An
optional callback may be specified to detect any DNS errors and when <code>buf</code> may be
re-used.  Note that DNS lookups will delay the time that a send takes place, at
least until the next tick.  The only way to know for sure that a send has taken place
is to use the callback.</p>

<p>If the socket has not been previously bound with a call to <code>bind</code>, it's
assigned a random port number and bound to the "all interfaces" address
(0.0.0.0 for <code>udp4</code> sockets, ::0 for <code>udp6</code> sockets).</p>

<p>Example of sending a UDP packet to a random port on <code>localhost</code>;</p>

<pre><code>var dgram = require('dgram');
var message = new Buffer("Some bytes");
var client = dgram.createSocket("udp4");
client.send(message, 0, message.length, 41234, "localhost", function(err, bytes) {
  client.close();
});</code></pre>

<p><strong>A Note about UDP datagram size</strong></p>

<p>The maximum size of an <code>IPv4/v6</code> datagram depends on the <code>MTU</code> (<em>Maximum Transmission Unit</em>)
and on the <code>Payload Length</code> field size.</p>

<ul><li><p>The <code>Payload Length</code> field is <code>16 bits</code> wide, which means that a normal payload
cannot be larger than 64K octets including internet header and data
(65,507 bytes = 65,535 − 8 bytes UDP header − 20 bytes IP header);
this is generally true for loopback interfaces, but such long datagrams
are impractical for most hosts and networks.</p></li><li><p>The <code>MTU</code> is the largest size a given link layer technology can support for datagrams.
For any link, <code>IPv4</code> mandates a minimum <code>MTU</code> of <code>68</code> octets, while the recommended <code>MTU</code>
for IPv4 is <code>576</code> (typically recommended as the <code>MTU</code> for dial-up type applications),
whether they arrive whole or in fragments.</p><p>For <code>IPv6</code>, the minimum <code>MTU</code> is <code>1280</code> octets, however, the mandatory minimum
fragment reassembly buffer size is <code>1500</code> octets.
The value of <code>68</code> octets is very small, since most current link layer technologies have
a minimum <code>MTU</code> of <code>1500</code> (like Ethernet).</p></li></ul>

<p>Note that it's impossible to know in advance the MTU of each link through which
a packet might travel, and that generally sending a datagram greater than
the (receiver) <code>MTU</code> won't work (the packet gets silently dropped, without
informing the source that the data did not reach its intended recipient).</p>

<h3 id="dgram.bind">dgram.bind(port, [address]) <a href="#dgram.bind">#</a></h3>

<p>For UDP sockets, listen for datagrams on a named <code>port</code> and optional <code>address</code>. If
<code>address</code> is not specified, the OS will try to listen on all addresses.</p>

<p>Example of a UDP server listening on port 41234:</p>

<pre><code>var dgram = require("dgram");

var server = dgram.createSocket("udp4");

server.on("message", function (msg, rinfo) {
  console.log("server got: " + msg + " from " +
    rinfo.address + ":" + rinfo.port);
});

server.on("listening", function () {
  var address = server.address();
  console.log("server listening " +
      address.address + ":" + address.port);
});

server.bind(41234);
// server listening 0.0.0.0:41234</code></pre>

<h3 id="dgram.close">dgram.close() <a href="#dgram.close">#</a></h3>

<p>Close the underlying socket and stop listening for data on it.</p>

<h3 id="dgram.address">dgram.address() <a href="#dgram.address">#</a></h3>

<p>Returns an object containing the address information for a socket.  For UDP sockets,
this object will contain <code>address</code> and <code>port</code>.</p>

<h3 id="dgram.setBroadcast">dgram.setBroadcast(flag) <a href="#dgram.setBroadcast">#</a></h3>

<p>Sets or clears the <code>SO_BROADCAST</code> socket option.  When this option is set, UDP packets
may be sent to a local interface's broadcast address.</p>

<h3 id="dgram.setTTL">dgram.setTTL(ttl) <a href="#dgram.setTTL">#</a></h3>

<p>Sets the <code>IP_TTL</code> socket option.  TTL stands for "Time to Live," but in this context it
specifies the number of IP hops that a packet is allowed to go through.  Each router or
gateway that forwards a packet decrements the TTL.  If the TTL is decremented to 0 by a
router, it will not be forwarded.  Changing TTL values is typically done for network
probes or when multicasting.</p>

<p>The argument to <code>setTTL()</code> is a number of hops between 1 and 255.  The default on most
systems is 64.</p>

<h3 id="dgram.setMulticastTTL">dgram.setMulticastTTL(ttl) <a href="#dgram.setMulticastTTL">#</a></h3>

<p>Sets the <code>IP_MULTICAST_TTL</code> socket option.  TTL stands for "Time to Live," but in this
context it specifies the number of IP hops that a packet is allowed to go through,
specifically for multicast traffic.  Each router or gateway that forwards a packet
decrements the TTL. If the TTL is decremented to 0 by a router, it will not be forwarded.</p>

<p>The argument to <code>setMulticastTTL()</code> is a number of hops between 0 and 255.  The default on most
systems is 64.</p>

<h3 id="dgram.setMulticastLoopback">dgram.setMulticastLoopback(flag) <a href="#dgram.setMulticastLoopback">#</a></h3>

<p>Sets or clears the <code>IP_MULTICAST_LOOP</code> socket option.  When this option is set, multicast
packets will also be received on the local interface.</p>

<h3 id="dgram.addMembership">dgram.addMembership(multicastAddress, [multicastInterface]) <a href="#dgram.addMembership">#</a></h3>

<p>Tells the kernel to join a multicast group with <code>IP_ADD_MEMBERSHIP</code> socket option.</p>

<p>If <code>multicastInterface</code> is not specified, the OS will try to add membership to all valid
interfaces.</p>

<h3 id="dgram.dropMembership">dgram.dropMembership(multicastAddress, [multicastInterface]) <a href="#dgram.dropMembership">#</a></h3>

<p>Opposite of <code>addMembership</code> - tells the kernel to leave a multicast group with
<code>IP_DROP_MEMBERSHIP</code> socket option. This is automatically called by the kernel
when the socket is closed or process terminates, so most apps will never need to call
this.</p>

<p>If <code>multicastInterface</code> is not specified, the OS will try to drop membership to all valid
interfaces.</p>

<h2 id="dNS">DNS</h2>

<p>Use <code>require('dns')</code> to access this module. All methods in the dns module
use C-Ares except for <code>dns.lookup</code> which uses <code>getaddrinfo(3)</code> in a thread
pool. C-Ares is much faster than <code>getaddrinfo</code> but the system resolver is
more constant with how other programs operate. When a user does
<code>net.connect(80, 'google.com')</code> or <code>http.get({ host: 'google.com' })</code> the
<code>dns.lookup</code> method is used. Users who need to do a large number of look ups
quickly should use the methods that go through C-Ares.</p>

<p>Here is an example which resolves <code>'www.google.com'</code> then reverse
resolves the IP addresses which are returned.</p>

<pre><code>var dns = require('dns');

dns.resolve4('www.google.com', function (err, addresses) {
  if (err) throw err;

  console.log('addresses: ' + JSON.stringify(addresses));

  addresses.forEach(function (a) {
    dns.reverse(a, function (err, domains) {
      if (err) {
        console.log('reverse for ' + a + ' failed: ' +
          err.message);
      } else {
        console.log('reverse for ' + a + ': ' +
          JSON.stringify(domains));
      }
    });
  });
});</code></pre>

<h3 id="dns.lookup">dns.lookup(domain, [family], callback) <a href="#dns.lookup">#</a></h3>

<p>Resolves a domain (e.g. <code>'google.com'</code>) into the first found A (IPv4) or
AAAA (IPv6) record.
The <code>family</code> can be the integer <code>4</code> or <code>6</code>. Defaults to <code>null</code> that indicates
both Ip v4 and v6 address family.</p>

<p>The callback has arguments <code>(err, address, family)</code>.  The <code>address</code> argument
is a string representation of a IP v4 or v6 address. The <code>family</code> argument
is either the integer 4 or 6 and denotes the family of <code>address</code> (not
necessarily the value initially passed to <code>lookup</code>).</p>

<h3 id="dns.resolve">dns.resolve(domain, [rrtype], callback) <a href="#dns.resolve">#</a></h3>

<p>Resolves a domain (e.g. <code>'google.com'</code>) into an array of the record types
specified by rrtype. Valid rrtypes are <code>'A'</code> (IPV4 addresses, default),
<code>'AAAA'</code> (IPV6 addresses), <code>'MX'</code> (mail exchange records), <code>'TXT'</code> (text
records), <code>'SRV'</code> (SRV records), <code>'PTR'</code> (used for reverse IP lookups),
<code>'NS'</code> (name server records) and <code>'CNAME'</code> (canonical name records).</p>

<p>The callback has arguments <code>(err, addresses)</code>.  The type of each item
in <code>addresses</code> is determined by the record type, and described in the
documentation for the corresponding lookup methods below.</p>

<p>On error, <code>err</code> would be an instanceof <code>Error</code> object, where <code>err.errno</code> is
one of the error codes listed below and <code>err.message</code> is a string describing
the error in English.</p>

<h3 id="dns.resolve4">dns.resolve4(domain, callback) <a href="#dns.resolve4">#</a></h3>

<p>The same as <code>dns.resolve()</code>, but only for IPv4 queries (<code>A</code> records).
<code>addresses</code> is an array of IPv4 addresses (e.g.
<code>['74.125.79.104', '74.125.79.105', '74.125.79.106']</code>).</p>

<h3 id="dns.resolve6">dns.resolve6(domain, callback) <a href="#dns.resolve6">#</a></h3>

<p>The same as <code>dns.resolve4()</code> except for IPv6 queries (an <code>AAAA</code> query).</p>

<h3 id="dns.resolveMx">dns.resolveMx(domain, callback) <a href="#dns.resolveMx">#</a></h3>

<p>The same as <code>dns.resolve()</code>, but only for mail exchange queries (<code>MX</code> records).</p>

<p><code>addresses</code> is an array of MX records, each with a priority and an exchange
attribute (e.g. <code>[{'priority': 10, 'exchange': 'mx.example.com'},...]</code>).</p>

<h3 id="dns.resolveTxt">dns.resolveTxt(domain, callback) <a href="#dns.resolveTxt">#</a></h3>

<p>The same as <code>dns.resolve()</code>, but only for text queries (<code>TXT</code> records).
<code>addresses</code> is an array of the text records available for <code>domain</code> (e.g.,
<code>['v=spf1 ip4:0.0.0.0 ~all']</code>).</p>

<h3 id="dns.resolveSrv">dns.resolveSrv(domain, callback) <a href="#dns.resolveSrv">#</a></h3>

<p>The same as <code>dns.resolve()</code>, but only for service records (<code>SRV</code> records).
<code>addresses</code> is an array of the SRV records available for <code>domain</code>. Properties
of SRV records are priority, weight, port, and name (e.g.,
<code>[{'priority': 10, {'weight': 5, 'port': 21223, 'name': 'service.example.com'}, ...]</code>).</p>

<h3 id="dns.reverse">dns.reverse(ip, callback) <a href="#dns.reverse">#</a></h3>

<p>Reverse resolves an ip address to an array of domain names.</p>

<p>The callback has arguments <code>(err, domains)</code>.</p>

<h3 id="dns.resolveNs">dns.resolveNs(domain, callback) <a href="#dns.resolveNs">#</a></h3>

<p>The same as <code>dns.resolve()</code>, but only for name server records (<code>NS</code> records).
<code>addresses</code> is an array of the name server records available for <code>domain</code>
(e.g., <code>['ns1.example.com', 'ns2.example.com']</code>).</p>

<h3 id="dns.resolveCname">dns.resolveCname(domain, callback) <a href="#dns.resolveCname">#</a></h3>

<p>The same as <code>dns.resolve()</code>, but only for canonical name records (<code>CNAME</code>
records). <code>addresses</code> is an array of the canonical name records available for
<code>domain</code> (e.g., <code>['bar.example.com']</code>).</p>

<p>If there an an error, <code>err</code> will be non-null and an instanceof the Error
object.</p>

<p>Each DNS query can return an error code.</p>

<ul><li><code>dns.TEMPFAIL</code>: timeout, SERVFAIL or similar.</li><li><code>dns.PROTOCOL</code>: got garbled reply.</li><li><code>dns.NXDOMAIN</code>: domain does not exists.</li><li><code>dns.NODATA</code>: domain exists but no data of reqd type.</li><li><code>dns.NOMEM</code>: out of memory while processing.</li><li><code>dns.BADQUERY</code>: the query is malformed.</li></ul>

<h2 id="hTTP">HTTP</h2>

<p>To use the HTTP server and client one must <code>require('http')</code>.</p>

<p>The HTTP interfaces in Node are designed to support many features
of the protocol which have been traditionally difficult to use.
In particular, large, possibly chunk-encoded, messages. The interface is
careful to never buffer entire requests or responses--the
user is able to stream data.</p>

<p>HTTP message headers are represented by an object like this:</p>

<pre><code>{ 'content-length': '123',
  'content-type': 'text/plain',
  'connection': 'keep-alive',
  'accept': '*/*' }</code></pre>

<p>Keys are lowercased. Values are not modified.</p>

<p>In order to support the full spectrum of possible HTTP applications, Node's
HTTP API is very low-level. It deals with stream handling and message
parsing only. It parses a message into headers and body but it does not
parse the actual headers or the body.</p>

<h2 id="http.Server">http.Server</h2>

<p>This is an <code>EventEmitter</code> with the following events:</p>

<h3 id="event_request_">Event: 'request' <a href="#event_request_">#</a></h3>

<p><code>function (request, response) { }</code></p>

<p>Emitted each time there is a request. Note that there may be multiple requests
per connection (in the case of keep-alive connections).
 <code>request</code> is an instance of <code>http.ServerRequest</code> and <code>response</code> is
 an instance of <code>http.ServerResponse</code></p>

<h3 id="event_connection_">Event: 'connection' <a href="#event_connection_">#</a></h3>

<p><code>function (socket) { }</code></p>

<p> When a new TCP stream is established. <code>socket</code> is an object of type
 <code>net.Socket</code>. Usually users will not want to access this event. The
 <code>socket</code> can also be accessed at <code>request.connection</code>.</p>

<h3 id="event_close_">Event: 'close' <a href="#event_close_">#</a></h3>

<p><code>function () { }</code></p>

<p> Emitted when the server closes.</p>

<h3 id="event_checkContinue_">Event: 'checkContinue' <a href="#event_checkContinue_">#</a></h3>

<p><code>function (request, response) { }</code></p>

<p>Emitted each time a request with an http Expect: 100-continue is received.
If this event isn't listened for, the server will automatically respond
with a 100 Continue as appropriate.</p>

<p>Handling this event involves calling <code>response.writeContinue</code> if the client
should continue to send the request body, or generating an appropriate HTTP
response (e.g., 400 Bad Request) if the client should not continue to send the
request body.</p>

<p>Note that when this event is emitted and handled, the <code>request</code> event will
not be emitted.</p>

<h3 id="event_upgrade_">Event: 'upgrade' <a href="#event_upgrade_">#</a></h3>

<p><code>function (request, socket, head) { }</code></p>

<p>Emitted each time a client requests a http upgrade. If this event isn't
listened for, then clients requesting an upgrade will have their connections
closed.</p>

<ul><li><code>request</code> is the arguments for the http request, as it is in the request event.</li><li><code>socket</code> is the network socket between the server and client.</li><li><code>head</code> is an instance of Buffer, the first packet of the upgraded stream, this may be empty.</li></ul>

<p>After this event is emitted, the request's socket will not have a <code>data</code>
event listener, meaning you will need to bind to it in order to handle data
sent to the server on that socket.</p>

<h3 id="event_clientError_">Event: 'clientError' <a href="#event_clientError_">#</a></h3>

<p><code>function (exception) { }</code></p>

<p>If a client connection emits an 'error' event - it will forwarded here.</p>

<h3 id="http.createServer">http.createServer([requestListener]) <a href="#http.createServer">#</a></h3>

<p>Returns a new web server object.</p>

<p>The <code>requestListener</code> is a function which is automatically
added to the <code>'request'</code> event.</p>

<h3 id="server.listen">server.listen(port, [hostname], [callback]) <a href="#server.listen">#</a></h3>

<p>Begin accepting connections on the specified port and hostname.  If the
hostname is omitted, the server will accept connections directed to any
IPv4 address (<code>INADDR_ANY</code>).</p>

<p>To listen to a unix socket, supply a filename instead of port and hostname.</p>

<p>This function is asynchronous. The last parameter <code>callback</code> will be added as
a listener for the <a href="net.html#event_listening_">'listening'</a> event.
See also <a href="net.html#server.listen">net.Server.listen()</a>.</p>

<h3 id="server.listen">server.listen(path, [callback]) <a href="#server.listen">#</a></h3>

<p>Start a UNIX socket server listening for connections on the given <code>path</code>.</p>

<p>This function is asynchronous. The last parameter <code>callback</code> will be added as
a listener for the <a href="net.html#event_listening_">'listening'</a> event.
See also <a href="net.html#server.listen">net.Server.listen()</a>.</p>

<h3 id="server.close">server.close() <a href="#server.close">#</a></h3>

<p>Stops the server from accepting new connections.
See <a href="net.html#server.close">net.Server.close()</a>.</p>

<h2 id="http.ServerRequest">http.ServerRequest</h2>

<p>This object is created internally by a HTTP server -- not by
the user -- and passed as the first argument to a <code>'request'</code> listener.</p>

<p>This is an <code>EventEmitter</code> with the following events:</p>

<h3 id="event_data_">Event: 'data' <a href="#event_data_">#</a></h3>

<p><code>function (chunk) { }</code></p>

<p>Emitted when a piece of the message body is received.</p>

<p>Example: A chunk of the body is given as the single
argument. The transfer-encoding has been decoded.  The
body chunk is a string.  The body encoding is set with
<code>request.setEncoding()</code>.</p>

<h3 id="event_end_">Event: 'end' <a href="#event_end_">#</a></h3>

<p><code>function () { }</code></p>

<p>Emitted exactly once for each request. After that, no more <code>'data'</code> events
will be emitted on the request.</p>

<h3 id="event_close_">Event: 'close' <a href="#event_close_">#</a></h3>

<p><code>function () { }</code></p>

<p>Indicates that the underlaying connection was terminated before
<code>response.end()</code> was called or able to flush.</p>

<p>Just like <code>'end'</code>, this event occurs only once per request, and no more <code>'data'</code>
events will fire afterwards.</p>

<p>Note: <code>'close'</code> can fire after <code>'end'</code>, but not vice versa.</p>

<h3 id="request.method">request.method <a href="#request.method">#</a></h3>

<p>The request method as a string. Read only. Example:
<code>'GET'</code>, <code>'DELETE'</code>.</p>

<h3 id="request.url">request.url <a href="#request.url">#</a></h3>

<p>Request URL string. This contains only the URL that is
present in the actual HTTP request. If the request is:</p>

<pre><code>GET /status?name=ryan HTTP/1.1\r\n
Accept: text/plain\r\n
\r\n</code></pre>

<p>Then <code>request.url</code> will be:</p>

<pre><code>'/status?name=ryan'</code></pre>

<p>If you would like to parse the URL into its parts, you can use
<code>require('url').parse(request.url)</code>.  Example:</p>

<pre><code>node&gt; require('url').parse('/status?name=ryan')
{ href: '/status?name=ryan',
  search: '?name=ryan',
  query: 'name=ryan',
  pathname: '/status' }</code></pre>

<p>If you would like to extract the params from the query string,
you can use the <code>require('querystring').parse</code> function, or pass
<code>true</code> as the second argument to <code>require('url').parse</code>.  Example:</p>

<pre><code>node&gt; require('url').parse('/status?name=ryan', true)
{ href: '/status?name=ryan',
  search: '?name=ryan',
  query: { name: 'ryan' },
  pathname: '/status' }</code></pre>

<h3 id="request.headers">request.headers <a href="#request.headers">#</a></h3>

<p>Read only.</p>

<h3 id="request.trailers">request.trailers <a href="#request.trailers">#</a></h3>

<p>Read only; HTTP trailers (if present). Only populated after the 'end' event.</p>

<h3 id="request.httpVersion">request.httpVersion <a href="#request.httpVersion">#</a></h3>

<p>The HTTP protocol version as a string. Read only. Examples:
<code>'1.1'</code>, <code>'1.0'</code>.
Also <code>request.httpVersionMajor</code> is the first integer and
<code>request.httpVersionMinor</code> is the second.</p>

<h3 id="request.setEncoding">request.setEncoding([encoding]) <a href="#request.setEncoding">#</a></h3>

<p>Set the encoding for the request body. Either <code>'utf8'</code> or <code>'binary'</code>. Defaults
to <code>null</code>, which means that the <code>'data'</code> event will emit a <code>Buffer</code> object..</p>

<h3 id="request.pause">request.pause() <a href="#request.pause">#</a></h3>

<p>Pauses request from emitting events.  Useful to throttle back an upload.</p>

<h3 id="request.resume">request.resume() <a href="#request.resume">#</a></h3>

<p>Resumes a paused request.</p>

<h3 id="request.connection">request.connection <a href="#request.connection">#</a></h3>

<p>The <code>net.Socket</code> object associated with the connection.</p>

<p>With HTTPS support, use request.connection.verifyPeer() and
request.connection.getPeerCertificate() to obtain the client's
authentication details.</p>

<h2 id="http.ServerResponse">http.ServerResponse</h2>

<p>This object is created internally by a HTTP server--not by the user. It is
passed as the second parameter to the <code>'request'</code> event. It is a <code>Writable Stream</code>.</p>

<h3 id="event_close_">Event: 'close' <a href="#event_close_">#</a></h3>

<p><code>function () { }</code></p>

<p>Indicates that the underlaying connection was terminated before
<code>response.end()</code> was called or able to flush.</p>

<h3 id="response.writeContinue">response.writeContinue() <a href="#response.writeContinue">#</a></h3>

<p>Sends a HTTP/1.1 100 Continue message to the client, indicating that
the request body should be sent. See the <a href="#event_checkContinue_">checkContinue</a> event on
<code>Server</code>.</p>

<h3 id="response.writeHead">response.writeHead(statusCode, [reasonPhrase], [headers]) <a href="#response.writeHead">#</a></h3>

<p>Sends a response header to the request. The status code is a 3-digit HTTP
status code, like <code>404</code>. The last argument, <code>headers</code>, are the response headers.
Optionally one can give a human-readable <code>reasonPhrase</code> as the second
argument.</p>

<p>Example:</p>

<pre><code>var body = 'hello world';
response.writeHead(200, {
  'Content-Length': body.length,
  'Content-Type': 'text/plain' });</code></pre>

<p>This method must only be called once on a message and it must
be called before <code>response.end()</code> is called.</p>

<p>If you call <code>response.write()</code> or <code>response.end()</code> before calling this, the
implicit/mutable headers will be calculated and call this function for you.</p>

<p>Note: that Content-Length is given in bytes not characters. The above example
works because the string <code>'hello world'</code> contains only single byte characters.
If the body contains higher coded characters then <code>Buffer.byteLength()</code>
should be used to determine the number of bytes in a given encoding.
And Node does not check whether Content-Length and the length of the body
which has been transmitted are equal or not.</p>

<h3 id="response.statusCode">response.statusCode <a href="#response.statusCode">#</a></h3>

<p>When using implicit headers (not calling <code>response.writeHead()</code> explicitly), this property
controls the status code that will be send to the client when the headers get
flushed.</p>

<p>Example:</p>

<pre><code>response.statusCode = 404;</code></pre>

<p>After response header was sent to the client, this property indicates the
status code which was sent out.</p>

<h3 id="response.setHeader">response.setHeader(name, value) <a href="#response.setHeader">#</a></h3>

<p>Sets a single header value for implicit headers.  If this header already exists
in the to-be-sent headers, its value will be replaced.  Use an array of strings
here if you need to send multiple headers with the same name.</p>

<p>Example:</p>

<pre><code>response.setHeader("Content-Type", "text/html");</code></pre>

<p>or</p>

<pre><code>response.setHeader("Set-Cookie", ["type=ninja", "language=javascript"]);</code></pre>

<h3 id="response.getHeader">response.getHeader(name) <a href="#response.getHeader">#</a></h3>

<p>Reads out a header that's already been queued but not sent to the client.  Note
that the name is case insensitive.  This can only be called before headers get
implicitly flushed.</p>

<p>Example:</p>

<pre><code>var contentType = response.getHeader('content-type');</code></pre>

<h3 id="response.removeHeader">response.removeHeader(name) <a href="#response.removeHeader">#</a></h3>

<p>Removes a header that's queued for implicit sending.</p>

<p>Example:</p>

<pre><code>response.removeHeader("Content-Encoding");</code></pre>

<h3 id="response.write">response.write(chunk, [encoding]) <a href="#response.write">#</a></h3>

<p>If this method is called and <code>response.writeHead()</code> has not been called, it will
switch to implicit header mode and flush the implicit headers.</p>

<p>This sends a chunk of the response body. This method may
be called multiple times to provide successive parts of the body.</p>

<p><code>chunk</code> can be a string or a buffer. If <code>chunk</code> is a string,
the second parameter specifies how to encode it into a byte stream.
By default the <code>encoding</code> is <code>'utf8'</code>.</p>

<p><strong>Note</strong>: This is the raw HTTP body and has nothing to do with
higher-level multi-part body encodings that may be used.</p>

<p>The first time <code>response.write()</code> is called, it will send the buffered
header information and the first body to the client. The second time
<code>response.write()</code> is called, Node assumes you're going to be streaming
data, and sends that separately. That is, the response is buffered up to the
first chunk of body.</p>

<h3 id="response.addTrailers">response.addTrailers(headers) <a href="#response.addTrailers">#</a></h3>

<p>This method adds HTTP trailing headers (a header but at the end of the
message) to the response.</p>

<p>Trailers will <strong>only</strong> be emitted if chunked encoding is used for the
response; if it is not (e.g., if the request was HTTP/1.0), they will
be silently discarded.</p>

<p>Note that HTTP requires the <code>Trailer</code> header to be sent if you intend to
emit trailers, with a list of the header fields in its value. E.g.,</p>

<pre><code>response.writeHead(200, { 'Content-Type': 'text/plain',
                          'Trailer': 'Content-MD5' });
response.write(fileData);
response.addTrailers({'Content-MD5': "7895bf4b8828b55ceaf47747b4bca667"});
response.end();</code></pre>

<h3 id="response.end">response.end([data], [encoding]) <a href="#response.end">#</a></h3>

<p>This method signals to the server that all of the response headers and body
has been sent; that server should consider this message complete.
The method, <code>response.end()</code>, MUST be called on each
response.</p>

<p>If <code>data</code> is specified, it is equivalent to calling <code>response.write(data, encoding)</code>
followed by <code>response.end()</code>.</p>

<h2 id="http.request">http.request(options, callback)</h2>

<p>Node maintains several connections per server to make HTTP requests.
This function allows one to transparently issue requests.  <code>options</code> align
with <a href="url.html#url.parse">url.parse()</a>.</p>

<p>Options:</p>

<ul><li><code>host</code>: A domain name or IP address of the server to issue the request to.
Defaults to <code>'localhost'</code>.</li><li><code>hostname</code>: To support <code>url.parse()</code> <code>hostname</code> is preferred over <code>host</code></li><li><code>port</code>: Port of remote server. Defaults to 80.</li><li><code>socketPath</code>: Unix Domain Socket (use one of host:port or socketPath)</li><li><code>method</code>: A string specifying the HTTP request method. Defaults to <code>'GET'</code>.</li><li><code>path</code>: Request path. Defaults to <code>'/'</code>. Should include query string if any.
E.G. <code>'/index.html?page=12'</code></li><li><code>headers</code>: An object containing request headers.</li><li><code>auth</code>: Basic authentication i.e. <code>'user:password'</code> to compute an
Authorization header.</li><li><code>agent</code>: Controls <a href="#http.Agent">Agent</a> behavior. When an Agent is used
request will default to <code>Connection: keep-alive</code>. Possible values:<ul><li><code>undefined</code> (default): use <a href="#http.globalAgent">global Agent</a> for this host
and port.</li><li><code>Agent</code> object: explicitly use the passed in <code>Agent</code>.</li><li><code>false</code>: opts out of connection pooling with an Agent, defaults request to
<code>Connection: close</code>.</li></ul></li></ul>

<p><code>http.request()</code> returns an instance of the <code>http.ClientRequest</code>
class. The <code>ClientRequest</code> instance is a writable stream. If one needs to
upload a file with a POST request, then write to the <code>ClientRequest</code> object.</p>

<p>Example:</p>

<pre><code>var options = {
  host: 'www.google.com',
  port: 80,
  path: '/upload',
  method: 'POST'
};

var req = http.request(options, function(res) {
  console.log('STATUS: ' + res.statusCode);
  console.log('HEADERS: ' + JSON.stringify(res.headers));
  res.setEncoding('utf8');
  res.on('data', function (chunk) {
    console.log('BODY: ' + chunk);
  });
});

req.on('error', function(e) {
  console.log('problem with request: ' + e.message);
});

// write data to request body
req.write('data\n');
req.write('data\n');
req.end();</code></pre>

<p>Note that in the example <code>req.end()</code> was called. With <code>http.request()</code> one
must always call <code>req.end()</code> to signify that you're done with the request -
even if there is no data being written to the request body.</p>

<p>If any error is encountered during the request (be that with DNS resolution,
TCP level errors, or actual HTTP parse errors) an <code>'error'</code> event is emitted
on the returned request object.</p>

<p>There are a few special headers that should be noted.</p>

<ul><li><p>Sending a 'Connection: keep-alive' will notify Node that the connection to
the server should be persisted until the next request.</p></li><li><p>Sending a 'Content-length' header will disable the default chunked encoding.</p></li><li><p>Sending an 'Expect' header will immediately send the request headers.
Usually, when sending 'Expect: 100-continue', you should both set a timeout
and listen for the <code>continue</code> event. See RFC2616 Section 8.2.3 for more
information.</p></li><li><p>Sending an Authorization header will override using the <code>auth</code> option
to compute basic authentication.</p></li></ul>

<h2 id="http.get">http.get(options, callback)</h2>

<p>Since most requests are GET requests without bodies, Node provides this
convenience method. The only difference between this method and <code>http.request()</code> is
that it sets the method to GET and calls <code>req.end()</code> automatically.</p>

<p>Example:</p>

<pre><code>var options = {
  host: 'www.google.com',
  port: 80,
  path: '/index.html'
};

http.get(options, function(res) {
  console.log("Got response: " + res.statusCode);
}).on('error', function(e) {
  console.log("Got error: " + e.message);
});</code></pre>

<h2 id="http.Agent">http.Agent</h2>

<p>In node 0.5.3+ there is a new implementation of the HTTP Agent which is used
for pooling sockets used in HTTP client requests.</p>

<p>Previously, a single agent instance help the pool for single host+port. The
current implementation now holds sockets for any number of hosts.</p>

<p>The current HTTP Agent also defaults client requests to using
Connection:keep-alive. If no pending HTTP requests are waiting on a socket
to become free the socket is closed. This means that node's pool has the
benefit of keep-alive when under load but still does not require developers
to manually close the HTTP clients using keep-alive.</p>

<p>Sockets are removed from the agent's pool when the socket emits either a
"close" event or a special "agentRemove" event. This means that if you intend
to keep one HTTP request open for a long time and don't want it to stay in the
pool you can do something along the lines of:</p>

<pre><code>http.get(options, function(res) {
  // Do stuff
}).on("socket", function (socket) {
  socket.emit("agentRemove");
});</code></pre>

<p>Alternatively, you could just opt out of pooling entirely using <code>agent:false</code>:</p>

<pre><code>http.get({host:'localhost', port:80, path:'/', agent:false}, function (res) {
  // Do stuff
})</code></pre>

<h2 id="http.globalAgent">http.globalAgent</h2>

<p>Global instance of Agent which is used as the default for all http client requests.</p>

<h3 id="agent.maxSockets">agent.maxSockets <a href="#agent.maxSockets">#</a></h3>

<p>By default set to 5. Determines how many concurrent sockets the agent can have 
open per host.</p>

<h3 id="agent.sockets">agent.sockets <a href="#agent.sockets">#</a></h3>

<p>An object which contains arrays of sockets currently in use by the Agent. Do not 
modify.</p>

<h3 id="agent.requests">agent.requests <a href="#agent.requests">#</a></h3>

<p>An object which contains queues of requests that have not yet been assigned to 
sockets. Do not modify.</p>

<h2 id="http.ClientRequest">http.ClientRequest</h2>

<p>This object is created internally and returned from <code>http.request()</code>.  It
represents an <em>in-progress</em> request whose header has already been queued.  The
header is still mutable using the <code>setHeader(name, value)</code>, <code>getHeader(name)</code>,
<code>removeHeader(name)</code> API.  The actual header will be sent along with the first
data chunk or when closing the connection.</p>

<p>To get the response, add a listener for <code>'response'</code> to the request object.
<code>'response'</code> will be emitted from the request object when the response
headers have been received.  The <code>'response'</code> event is executed with one
argument which is an instance of <code>http.ClientResponse</code>.</p>

<p>During the <code>'response'</code> event, one can add listeners to the
response object; particularly to listen for the <code>'data'</code> event. Note that
the <code>'response'</code> event is called before any part of the response body is received,
so there is no need to worry about racing to catch the first part of the
body. As long as a listener for <code>'data'</code> is added during the <code>'response'</code>
event, the entire body will be caught.</p>

<pre><code>// Good
request.on('response', function (response) {
  response.on('data', function (chunk) {
    console.log('BODY: ' + chunk);
  });
});

// Bad - misses all or part of the body
request.on('response', function (response) {
  setTimeout(function () {
    response.on('data', function (chunk) {
      console.log('BODY: ' + chunk);
    });
  }, 10);
});</code></pre>

<p>This is a <code>Writable Stream</code>.
Note: Node does not check whether Content-Length and the length of the body
which has been transmitted are equal or not.</p>

<p>This is an <code>EventEmitter</code> with the following events:</p>

<h3 id="event_response_">Event 'response' <a href="#event_response_">#</a></h3>

<p><code>function (response) { }</code></p>

<p>Emitted when a response is received to this request. This event is emitted only once. The
<code>response</code> argument will be an instance of <code>http.ClientResponse</code>.</p>

<p>Options:</p>

<ul><li><code>host</code>: A domain name or IP address of the server to issue the request to.</li><li><code>port</code>: Port of remote server.</li><li><code>socketPath</code>: Unix Domain Socket (use one of host:port or socketPath)</li></ul>

<h3 id="event_socket_">Event: 'socket' <a href="#event_socket_">#</a></h3>

<p><code>function (socket) { }</code></p>

<p>Emitted after a socket is assigned to this request.</p>

<h3 id="event_upgrade_">Event: 'upgrade' <a href="#event_upgrade_">#</a></h3>

<p><code>function (response, socket, head) { }</code></p>

<p>Emitted each time a server responds to a request with an upgrade. If this
event isn't being listened for, clients receiving an upgrade header will have
their connections closed.</p>

<p>A client server pair that show you how to listen for the <code>upgrade</code> event using <code>http.getAgent</code>:</p>

<pre><code>var http = require('http');
var net = require('net');

// Create an HTTP server
var srv = http.createServer(function (req, res) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('okay');
});
srv.on('upgrade', function(req, socket, upgradeHead) {
  socket.write('HTTP/1.1 101 Web Socket Protocol Handshake\r\n' +
               'Upgrade: WebSocket\r\n' +
               'Connection: Upgrade\r\n' +
               '\r\n\r\n');

  socket.ondata = function(data, start, end) {
    socket.write(data.toString('utf8', start, end), 'utf8'); // echo back
  };
});

// now that server is running
srv.listen(1337, '127.0.0.1', function() {

  // make a request
  var options = {
    port: 1337,
    host: '127.0.0.1',
    headers: {
      'Connection': 'Upgrade',
      'Upgrade': 'websocket'
    }
  };

  var req = http.request(options);
  req.end();

  req.on('upgrade', function(res, socket, upgradeHead) {
    console.log('got upgraded!');
    socket.end();
    process.exit(0);
  });
});</code></pre>

<h3 id="event_continue_">Event: 'continue' <a href="#event_continue_">#</a></h3>

<p><code>function () { }</code></p>

<p>Emitted when the server sends a '100 Continue' HTTP response, usually because
the request contained 'Expect: 100-continue'. This is an instruction that
the client should send the request body.</p>

<h3 id="request.write">request.write(chunk, [encoding]) <a href="#request.write">#</a></h3>

<p>Sends a chunk of the body.  By calling this method
many times, the user can stream a request body to a
server--in that case it is suggested to use the
<code>['Transfer-Encoding', 'chunked']</code> header line when
creating the request.</p>

<p>The <code>chunk</code> argument should be an array of integers
or a string.</p>

<p>The <code>encoding</code> argument is optional and only applies when <code>chunk</code> is a string.
Defaults to <code>'utf8'</code>.</p>

<h3 id="request.end">request.end([data], [encoding]) <a href="#request.end">#</a></h3>

<p>Finishes sending the request. If any parts of the body are
unsent, it will flush them to the stream. If the request is
chunked, this will send the terminating <code>'0\r\n\r\n'</code>.</p>

<p>If <code>data</code> is specified, it is equivalent to calling
<code>request.write(data, encoding)</code> followed by <code>request.end()</code>.</p>

<h3 id="request.abort">request.abort() <a href="#request.abort">#</a></h3>

<p>Aborts a request.  (New since v0.3.8.)</p>

<h3 id="request.setTimeout">request.setTimeout(timeout, [callback]) <a href="#request.setTimeout">#</a></h3>

<p>Once a socket is assigned to this request and is connected 
<a href="net.html#socket.setTimeout">socket.setTimeout(timeout, [callback])</a>
will be called.</p>

<h3 id="request.setNoDelay">request.setNoDelay([noDelay]) <a href="#request.setNoDelay">#</a></h3>

<p>Once a socket is assigned to this request and is connected 
<a href="net.html#socket.setNoDelay">socket.setNoDelay(noDelay)</a>
will be called.</p>

<h3 id="request.setSocketKeepAlive">request.setSocketKeepAlive([enable], [initialDelay]) <a href="#request.setSocketKeepAlive">#</a></h3>

<p>Once a socket is assigned to this request and is connected 
<a href="net.html#socket.setKeepAlive">socket.setKeepAlive(enable, [initialDelay])</a>
will be called.</p>

<h2 id="http.ClientResponse">http.ClientResponse</h2>

<p>This object is created when making a request with <code>http.request()</code>. It is
passed to the <code>'response'</code> event of the request object.</p>

<p>The response implements the <code>Readable Stream</code> interface.</p>

<h3 id="event_data_">Event: 'data' <a href="#event_data_">#</a></h3>

<p><code>function (chunk) { }</code></p>

<p>Emitted when a piece of the message body is received.</p>

<h3 id="event_end_">Event: 'end' <a href="#event_end_">#</a></h3>

<p><code>function () { }</code></p>

<p>Emitted exactly once for each message. No arguments. After
emitted no other events will be emitted on the response.</p>

<h3 id="event_close_">Event: 'close' <a href="#event_close_">#</a></h3>

<p><code>function (err) { }</code></p>

<p>Indicates that the underlaying connection was terminated before
<code>end</code> event was emitted.
See <a href="#http.ServerRequest">http.ServerRequest</a>'s <code>'close'</code> event for more
information.</p>

<h3 id="response.statusCode">response.statusCode <a href="#response.statusCode">#</a></h3>

<p>The 3-digit HTTP response status code. E.G. <code>404</code>.</p>

<h3 id="response.httpVersion">response.httpVersion <a href="#response.httpVersion">#</a></h3>

<p>The HTTP version of the connected-to server. Probably either
<code>'1.1'</code> or <code>'1.0'</code>.
Also <code>response.httpVersionMajor</code> is the first integer and
<code>response.httpVersionMinor</code> is the second.</p>

<h3 id="response.headers">response.headers <a href="#response.headers">#</a></h3>

<p>The response headers object.</p>

<h3 id="response.trailers">response.trailers <a href="#response.trailers">#</a></h3>

<p>The response trailers object. Only populated after the 'end' event.</p>

<h3 id="response.setEncoding">response.setEncoding([encoding]) <a href="#response.setEncoding">#</a></h3>

<p>Set the encoding for the response body. Either <code>'utf8'</code>, <code>'ascii'</code>, or
<code>'base64'</code>. Defaults to <code>null</code>, which means that the <code>'data'</code> event will emit
a <code>Buffer</code> object..</p>

<h3 id="response.pause">response.pause() <a href="#response.pause">#</a></h3>

<p>Pauses response from emitting events.  Useful to throttle back a download.</p>

<h3 id="response.resume">response.resume() <a href="#response.resume">#</a></h3>

<p>Resumes a paused response.</p>

<h2 id="hTTPS">HTTPS</h2>

<p>HTTPS is the HTTP protocol over TLS/SSL. In Node this is implemented as a
separate module.</p>

<h2 id="https.Server">https.Server</h2>

<p>This class is a subclass of <code>tls.Server</code> and emits events same as
<code>http.Server</code>. See <code>http.Server</code> for more information.</p>

<h2 id="https.createServer">https.createServer(options, [requestListener])</h2>

<p>Returns a new HTTPS web server object. The <code>options</code> is similar to
<code>tls.createServer()</code>. The <code>requestListener</code> is a function which is
automatically added to the <code>'request'</code> event.</p>

<p>Example:</p>

<pre><code>// curl -k https://localhost:8000/
var https = require('https');
var fs = require('fs');

var options = {
  key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),
  cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem')
};

https.createServer(options, function (req, res) {
  res.writeHead(200);
  res.end("hello world\n");
}).listen(8000);</code></pre>

<h2 id="https.request">https.request(options, callback)</h2>

<p>Makes a request to a secure web server.
All options from <a href="http.html#http.request">http.request()</a> are valid.</p>

<p>Example:</p>

<pre><code>var https = require('https');

var options = {
  host: 'encrypted.google.com',
  port: 443,
  path: '/',
  method: 'GET'
};

var req = https.request(options, function(res) {
  console.log("statusCode: ", res.statusCode);
  console.log("headers: ", res.headers);

  res.on('data', function(d) {
    process.stdout.write(d);
  });
});
req.end();

req.on('error', function(e) {
  console.error(e);
});</code></pre>

<p>The options argument has the following options</p>

<ul><li>host: IP or domain of host to make request to. Defaults to <code>'localhost'</code>.</li><li>port: port of host to request to. Defaults to 443.</li><li>path: Path to request. Default <code>'/'</code>.</li><li><p>method: HTTP request method. Default <code>'GET'</code>.</p></li><li><p><code>host</code>: A domain name or IP address of the server to issue the request to.
Defaults to <code>'localhost'</code>.</p></li><li><code>hostname</code>: To support <code>url.parse()</code> <code>hostname</code> is preferred over <code>host</code></li><li><code>port</code>: Port of remote server. Defaults to 443.</li><li><code>method</code>: A string specifying the HTTP request method. Defaults to <code>'GET'</code>.</li><li><code>path</code>: Request path. Defaults to <code>'/'</code>. Should include query string if any.
E.G. <code>'/index.html?page=12'</code></li><li><code>headers</code>: An object containing request headers.</li><li><code>auth</code>: Basic authentication i.e. <code>'user:password'</code> to compute an
Authorization header.</li><li><code>agent</code>: Controls <a href="#https.Agent">Agent</a> behavior. When an Agent is
used request will default to <code>Connection: keep-alive</code>. Possible values:<ul><li><code>undefined</code> (default): use <a href="#https.globalAgent">globalAgent</a> for this
host and port.</li><li><code>Agent</code> object: explicitly use the passed in <code>Agent</code>.</li><li><code>false</code>: opts out of connection pooling with an Agent, defaults request to
<code>Connection: close</code>.</li></ul></li></ul>

<p>The following options from <a href="tls.html#tls.connect">tls.connect()</a> can also be
specified. However, a <a href="#https.globalAgent">globalAgent</a> silently ignores these.</p>

<ul><li><code>key</code>: Private key to use for SSL. Default <code>null</code>.</li><li><code>passphrase</code>: A string of passphrase for the private key. Default <code>null</code>.</li><li><code>cert</code>: Public x509 certificate to use. Default <code>null</code>.</li><li><code>ca</code>: An authority certificate or array of authority certificates to check
the remote host against.</li></ul>

<p>In order to specify these options, use a custom <code>Agent</code>.</p>

<p>Example:</p>

<pre><code>var options = {
  host: 'encrypted.google.com',
  port: 443,
  path: '/',
  method: 'GET',
  key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),
  cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem')
};
options.agent = new https.Agent(options);

var req = https.request(options, function(res) {
  ...
}</code></pre>

<p>Or does not use an <code>Agent</code>.</p>

<p>Example:</p>

<pre><code>var options = {
  host: 'encrypted.google.com',
  port: 443,
  path: '/',
  method: 'GET',
  key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),
  cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem'),
  agent: false
};

var req = https.request(options, function(res) {
  ...
}</code></pre>

<h2 id="https.get">https.get(options, callback)</h2>

<p>Like <code>http.get()</code> but for HTTPS.</p>

<p>Example:</p>

<pre><code>var https = require('https');

https.get({ host: 'encrypted.google.com', path: '/' }, function(res) {
  console.log("statusCode: ", res.statusCode);
  console.log("headers: ", res.headers);

  res.on('data', function(d) {
    process.stdout.write(d);
  });

}).on('error', function(e) {
  console.error(e);
});</code></pre>

<h2 id="https.Agent">https.Agent</h2>

<p>An Agent object for HTTPS similar to <a href="http.html#http.Agent">http.Agent</a>.
See <a href="#https.request">https.request()</a> for more information.</p>

<h2 id="https.globalAgent">https.globalAgent</h2>

<p>Global instance of <a href="#https.Agent">https.Agent</a> which is used as the default
for all HTTPS client requests.</p>

<h2 id="uRL">URL</h2>

<p>This module has utilities for URL resolution and parsing.
Call <code>require('url')</code> to use it.</p>

<p>Parsed URL objects have some or all of the following fields, depending on
whether or not they exist in the URL string. Any parts that are not in the URL
string will not be in the parsed object. Examples are shown for the URL</p>

<p><code>'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'</code></p>

<ul><li><p><code>href</code>: The full URL that was originally parsed. Both the protocol and host are lowercased.</p><p>Example: <code>'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'</code></p></li><li><p><code>protocol</code>: The request protocol, lowercased.</p><p>Example: <code>'http:'</code></p></li><li><p><code>host</code>: The full lowercased host portion of the URL, including port and authentication information.</p><p>Example: <code>'user:pass@host.com:8080'</code></p></li><li><p><code>auth</code>: The authentication information portion of a URL.</p><p>Example: <code>'user:pass'</code></p></li><li><p><code>hostname</code>: Just the lowercased hostname portion of the host.</p><p>Example: <code>'host.com'</code></p></li><li><p><code>port</code>: The port number portion of the host.</p><p>Example: <code>'8080'</code></p></li><li><p><code>pathname</code>: The path section of the URL, that comes after the host and before the query, including the initial slash if present.</p><p>Example: <code>'/p/a/t/h'</code></p></li><li><p><code>search</code>: The 'query string' portion of the URL, including the leading question mark.</p><p>Example: <code>'?query=string'</code></p></li><li><p><code>path</code>: Concatenation of <code>pathname</code> and <code>search</code>.</p><p>Example: <code>'/p/a/t/h?query=string'</code></p></li><li><p><code>query</code>: Either the 'params' portion of the query string, or a querystring-parsed object.</p><p>Example: <code>'query=string'</code> or <code>{'query':'string'}</code></p></li><li><p><code>hash</code>: The 'fragment' portion of the URL including the pound-sign.</p><p>Example: <code>'#hash'</code></p></li></ul>

<p>The following methods are provided by the URL module:</p>

<h3 id="url.parse">url.parse(urlStr, [parseQueryString], [slashesDenoteHost]) <a href="#url.parse">#</a></h3>

<p>Take a URL string, and return an object.</p>

<p>Pass <code>true</code> as the second argument to also parse
the query string using the <code>querystring</code> module.
Defaults to <code>false</code>.</p>

<p>Pass <code>true</code> as the third argument to treat <code>//foo/bar</code> as
<code>{ host: 'foo', pathname: '/bar' }</code> rather than
<code>{ pathname: '//foo/bar' }</code>. Defaults to <code>false</code>.</p>

<h3 id="url.format">url.format(urlObj) <a href="#url.format">#</a></h3>

<p>Take a parsed URL object, and return a formatted URL string.</p>

<ul><li><code>href</code> will be ignored.</li><li><code>protocol</code>is treated the same with or without the trailing <code>:</code> (colon).<ul><li>The protocols <code>http</code>, <code>https</code>, <code>ftp</code>, <code>gopher</code>, <code>file</code> will be postfixed with <code>://</code> (colon-slash-slash).</li><li>All other protocols <code>mailto</code>, <code>xmpp</code>, <code>aim</code>, <code>sftp</code>, <code>foo</code>, etc will be postfixed with <code>:</code> (colon)</li></ul></li><li><code>auth</code> will only be used if <code>host</code> is absent.</li><li><code>hostname</code> will only be used if <code>host</code> is absent.</li><li><code>port</code> will only be used if <code>host</code> is absent.</li><li><code>host</code> will be used in place of <code>auth</code>, <code>hostname</code>, and <code>port</code></li><li><code>pathname</code> is treated the same with or without the leading <code>/</code> (slash)</li><li><code>search</code> will be used in place of <code>query</code></li><li><code>query</code> (object; see <code>querystring</code>) will only be used if <code>search</code> is absent.</li><li><code>search</code> is treated the same with or without the leading <code>?</code> (question mark)</li><li><code>hash</code> is treated the same with or without the leading <code>#</code> (pound sign, anchor)</li></ul>

<h3 id="url.resolve">url.resolve(from, to) <a href="#url.resolve">#</a></h3>

<p>Take a base URL, and a href URL, and resolve them as a browser would for an anchor tag.</p>

<h2 id="query_String">Query String</h2>

<p>This module provides utilities for dealing with query strings.
It provides the following methods:</p>

<h3 id="querystring.stringify">querystring.stringify(obj, [sep], [eq]) <a href="#querystring.stringify">#</a></h3>

<p>Serialize an object to a query string.
Optionally override the default separator (<code>'&amp;'</code>) and assignment (<code>'='</code>)
characters.</p>

<p>Example:</p>

<pre><code>querystring.stringify({ foo: 'bar', baz: ['qux', 'quux'], corge: '' })
// returns
'foo=bar&amp;baz=qux&amp;baz=quux&amp;corge='

querystring.stringify({foo: 'bar', baz: 'qux'}, ';', ':')
// returns
'foo:bar;baz:qux'</code></pre>

<h3 id="querystring.parse">querystring.parse(str, [sep], [eq]) <a href="#querystring.parse">#</a></h3>

<p>Deserialize a query string to an object.
Optionally override the default separator (<code>'&amp;'</code>) and assignment (<code>'='</code>)
characters.</p>

<p>Example:</p>

<pre><code>querystring.parse('foo=bar&amp;baz=qux&amp;baz=quux&amp;corge')
// returns
{ foo: 'bar', baz: ['qux', 'quux'], corge: '' }</code></pre>

<h3 id="querystring.escape">querystring.escape <a href="#querystring.escape">#</a></h3>

<p>The escape function used by <code>querystring.stringify</code>,
provided so that it could be overridden if necessary.</p>

<h3 id="querystring.unescape">querystring.unescape <a href="#querystring.unescape">#</a></h3>

<p>The unescape function used by <code>querystring.parse</code>,
provided so that it could be overridden if necessary.</p>

<h2 id="readline">Readline</h2>

<p>To use this module, do <code>require('readline')</code>. Readline allows reading of a
stream (such as STDIN) on a line-by-line basis.</p>

<p>Note that once you've invoked this module, your node program will not
terminate until you've closed the interface, and the STDIN stream. Here's how
to allow your program to gracefully terminate:</p>

<pre><code>var rl = require('readline');

var i = rl.createInterface(process.stdin, process.stdout, null);
i.question("What do you think of node.js?", function(answer) {
  // TODO: Log the answer in a database
  console.log("Thank you for your valuable feedback.");

  // These two lines together allow the program to terminate. Without
  // them, it would run forever.
  i.close();
  process.stdin.destroy();
});</code></pre>

<h3 id="rl.createInterface">rl.createInterface(input, output, completer) <a href="#rl.createInterface">#</a></h3>

<p>Takes two streams and creates a readline interface. The <code>completer</code> function
is used for autocompletion. When given a substring, it returns <code>[[substr1,
substr2, ...], originalsubstring]</code>.</p>

<p>Also <code>completer</code> can be run in async mode if it accepts two arguments:</p>

<p>  function completer(linePartial, callback) {
    callback(null, [['123'], linePartial]);
  }</p>

<p><code>createInterface</code> is commonly used with <code>process.stdin</code> and
<code>process.stdout</code> in order to accept user input:</p>

<pre><code>var readline = require('readline'),
  rl = readline.createInterface(process.stdin, process.stdout);</code></pre>

<h3 id="rl.setPrompt">rl.setPrompt(prompt, length) <a href="#rl.setPrompt">#</a></h3>

<p>Sets the prompt, for example when you run <code>node</code> on the command line, you see
<code>&gt; </code>, which is node's prompt.</p>

<h3 id="rl.prompt">rl.prompt() <a href="#rl.prompt">#</a></h3>

<p>Readies readline for input from the user, putting the current <code>setPrompt</code>
options on a new line, giving the user a new spot to write.</p>

<p>&lt;!-- ### rl.getColumns() Not available? --&gt;</p>

<h3 id="rl.question">rl.question(query, callback) <a href="#rl.question">#</a></h3>

<p>Prepends the prompt with <code>query</code> and invokes <code>callback</code> with the user's
response. Displays the query to the user, and then invokes <code>callback</code> with the
user's response after it has been typed.</p>

<p>Example usage:</p>

<pre><code>interface.question('What is your favorite food?', function(answer) {
  console.log('Oh, so your favorite food is ' + answer);
});</code></pre>

<h3 id="rl.close">rl.close() <a href="#rl.close">#</a></h3>

<p>  Closes tty.</p>

<h3 id="rl.pause">rl.pause() <a href="#rl.pause">#</a></h3>

<p>  Pauses tty.</p>

<h3 id="rl.resume">rl.resume() <a href="#rl.resume">#</a></h3>

<p>  Resumes tty.</p>

<h3 id="rl.write">rl.write() <a href="#rl.write">#</a></h3>

<p>  Writes to tty.</p>

<h3 id="event_line_">Event: 'line' <a href="#event_line_">#</a></h3>

<p><code>function (line) {}</code></p>

<p>Emitted whenever the <code>in</code> stream receives a <code>\n</code>, usually received when the
user hits enter, or return. This is a good hook to listen for user input.</p>

<p>Example of listening for <code>line</code>:</p>

<pre><code>rl.on('line', function (cmd) {
  console.log('You just typed: '+cmd);
});</code></pre>

<h3 id="event_close_">Event: 'close' <a href="#event_close_">#</a></h3>

<p><code>function () {}</code></p>

<p>Emitted whenever the <code>in</code> stream receives a <code>^C</code> or <code>^D</code>, respectively known
as <code>SIGINT</code> and <code>EOT</code>. This is a good way to know the user is finished using
your program.</p>

<p>Example of listening for <code>close</code>, and exiting the program afterward:</p>

<pre><code>rl.on('close', function() {
  console.log('goodbye!');
  process.exit(0);
});</code></pre>

<p>Here's an example of how to use all these together to craft a tiny command
line interface:</p>

<pre><code>var readline = require('readline'),
  rl = readline.createInterface(process.stdin, process.stdout),
  prefix = 'OHAI&gt; ';

rl.on('line', function(line) {
  switch(line.trim()) {
    case 'hello':
      console.log('world!');
      break;
    default:
      console.log('Say what? I might have heard `' + line.trim() + '`');
      break;
  }
  rl.setPrompt(prefix, prefix.length);
  rl.prompt();
}).on('close', function() {
  console.log('Have a great day!');
  process.exit(0);
});
console.log(prefix + 'Good to see you. Try typing stuff.');
rl.setPrompt(prefix, prefix.length);
rl.prompt();</code></pre>

<p>Take a look at this slightly more complicated
<a href="https://gist.github.com/901104">example</a>, and
<a href="https://github.com/cloudhead/http-console">http-console</a> for a real-life use
case.</p>

<h2 id="rEPL">REPL</h2>

<p>A Read-Eval-Print-Loop (REPL) is available both as a standalone program and easily
includable in other programs.  REPL provides a way to interactively run
JavaScript and see the results.  It can be used for debugging, testing, or
just trying things out.</p>

<p>By executing <code>node</code> without any arguments from the command-line you will be
dropped into the REPL. It has simplistic emacs line-editing.</p>

<pre><code>mjr:~$ node
Type '.help' for options.
&gt; a = [ 1, 2, 3];
[ 1, 2, 3 ]
&gt; a.forEach(function (v) {
...   console.log(v);
...   });
1
2
3</code></pre>

<p>For advanced line-editors, start node with the environmental variable <code>NODE_NO_READLINE=1</code>.
This will start the REPL in canonical terminal settings which will allow you to use with <code>rlwrap</code>.</p>

<p>For example, you could add this to your bashrc file:</p>

<pre><code>alias node="env NODE_NO_READLINE=1 rlwrap node"</code></pre>

<h3 id="repl.start">repl.start([prompt], [stream], [eval], [useGlobal], [ignoreUndefined]) <a href="#repl.start">#</a></h3>

<p>Starts a REPL with <code>prompt</code> as the prompt and <code>stream</code> for all I/O.  <code>prompt</code>
is optional and defaults to <code>&gt; </code>.  <code>stream</code> is optional and defaults to
<code>process.stdin</code>. <code>eval</code> is optional too and defaults to async wrapper for
<code>eval()</code>.</p>

<p>If <code>useGlobal</code> is set to true, then the repl will use the global object,
instead of running scripts in a separate context. Defaults to <code>false</code>.</p>

<p>If <code>ignoreUndefined</code> is set to true, then the repl will not output return value
of command if it's <code>undefined</code>. Defaults to <code>false</code>.</p>

<p>You can use your own <code>eval</code> function if it has following signature:</p>

<pre><code>function eval(cmd, callback) {
  callback(null, result);
}</code></pre>

<p>Multiple REPLs may be started against the same running instance of node.  Each
will share the same global object but will have unique I/O.</p>

<p>Here is an example that starts a REPL on stdin, a Unix socket, and a TCP socket:</p>

<pre><code>var net = require("net"),
    repl = require("repl");

connections = 0;

repl.start("node via stdin&gt; ");

net.createServer(function (socket) {
  connections += 1;
  repl.start("node via Unix socket&gt; ", socket);
}).listen("/tmp/node-repl-sock");

net.createServer(function (socket) {
  connections += 1;
  repl.start("node via TCP socket&gt; ", socket);
}).listen(5001);</code></pre>

<p>Running this program from the command line will start a REPL on stdin.  Other
REPL clients may connect through the Unix socket or TCP socket. <code>telnet</code> is useful
for connecting to TCP sockets, and <code>socat</code> can be used to connect to both Unix and
TCP sockets.</p>

<p>By starting a REPL from a Unix socket-based server instead of stdin, you can
connect to a long-running node process without restarting it.</p>

<h3 id="rEPL_Features">REPL Features <a href="#rEPL_Features">#</a></h3>

<p>Inside the REPL, Control+D will exit.  Multi-line expressions can be input.
Tab completion is supported for both global and local variables.</p>

<p>The special variable <code>_</code> (underscore) contains the result of the last expression.</p>

<pre><code>&gt; [ "a", "b", "c" ]
[ 'a', 'b', 'c' ]
&gt; _.length
3
&gt; _ += 1
4</code></pre>

<p>The REPL provides access to any variables in the global scope. You can expose
a variable to the REPL explicitly by assigning it to the <code>context</code> object
associated with each <code>REPLServer</code>.  For example:</p>

<pre><code>// repl_test.js
var repl = require("repl"),
    msg = "message";

repl.start().context.m = msg;</code></pre>

<p>Things in the <code>context</code> object appear as local within the REPL:</p>

<pre><code>mjr:~$ node repl_test.js
&gt; m
'message'</code></pre>

<p>There are a few special REPL commands:</p>

<ul><li><code>.break</code> - While inputting a multi-line expression, sometimes you get lost
or just don't care about completing it. <code>.break</code> will start over.</li><li><code>.clear</code> - Resets the <code>context</code> object to an empty object and clears any
multi-line expression.</li><li><code>.exit</code> - Close the I/O stream, which will cause the REPL to exit.</li><li><code>.help</code> - Show this list of special commands.</li><li><code>.save</code> - Save the current REPL session to a file
&gt;.save ./file/to/save.js</li><li><code>.load</code> - Load a file into the current REPL session.
&gt;.load ./file/to/load.js</li></ul>

<p>The following key combinations in the REPL have these special effects:</p>

<ul><li><code>&lt;ctrl&gt;C</code> - Similar to the <code>.break</code> keyword.  Terminates the current
command.  Press twice on a blank line to forcibly exit.</li><li><code>&lt;ctrl&gt;D</code> - Similar to the <code>.exit</code> keyword.</li></ul>

<h2 id="executing_JavaScript">Executing JavaScript</h2>

<p>You can access this module with:</p>

<pre><code>var vm = require('vm');</code></pre>

<p>JavaScript code can be compiled and run immediately or compiled, saved, and run later.</p>

<h3 id="vm.runInThisContext">vm.runInThisContext(code, [filename]) <a href="#vm.runInThisContext">#</a></h3>

<p><code>vm.runInThisContext()</code> compiles <code>code</code> as if it were loaded from <code>filename</code>,
runs it and returns the result. Running code does not have access to local scope. <code>filename</code> is optional.</p>

<p>Example of using <code>vm.runInThisContext</code> and <code>eval</code> to run the same code:</p>

<pre><code>var localVar = 123,
    usingscript, evaled,
    vm = require('vm');

usingscript = vm.runInThisContext('localVar = 1;',
  'myfile.vm');
console.log('localVar: ' + localVar + ', usingscript: ' +
  usingscript);
evaled = eval('localVar = 1;');
console.log('localVar: ' + localVar + ', evaled: ' +
  evaled);

// localVar: 123, usingscript: 1
// localVar: 1, evaled: 1</code></pre>

<p><code>vm.runInThisContext</code> does not have access to the local scope, so <code>localVar</code> is unchanged.
<code>eval</code> does have access to the local scope, so <code>localVar</code> is changed.</p>

<p>In case of syntax error in <code>code</code>, <code>vm.runInThisContext</code> emits the syntax error to stderr
and throws an exception.</p>

<h3 id="vm.runInNewContext">vm.runInNewContext(code, [sandbox], [filename]) <a href="#vm.runInNewContext">#</a></h3>

<p><code>vm.runInNewContext</code> compiles <code>code</code> to run in <code>sandbox</code> as if it were loaded from <code>filename</code>,
then runs it and returns the result. Running code does not have access to local scope and
the object <code>sandbox</code> will be used as the global object for <code>code</code>.
<code>sandbox</code> and <code>filename</code> are optional.</p>

<p>Example: compile and execute code that increments a global variable and sets a new one.
These globals are contained in the sandbox.</p>

<pre><code>var util = require('util'),
    vm = require('vm'),
    sandbox = {
      animal: 'cat',
      count: 2
    };

vm.runInNewContext('count += 1; name = "kitty"', sandbox, 'myfile.vm');
console.log(util.inspect(sandbox));

// { animal: 'cat', count: 3, name: 'kitty' }</code></pre>

<p>Note that running untrusted code is a tricky business requiring great care.  To prevent accidental
global variable leakage, <code>vm.runInNewContext</code> is quite useful, but safely running untrusted code
requires a separate process.</p>

<p>In case of syntax error in <code>code</code>, <code>vm.runInNewContext</code> emits the syntax error to stderr
and throws an exception.</p>

<h3 id="vm.runInContext">vm.runInContext(code, context, [filename]) <a href="#vm.runInContext">#</a></h3>

<p><code>vm.runInContext</code> compiles <code>code</code> to run in context <code>context</code> as if it were loaded from <code>filename</code>,
then runs it and returns the result. A (V8) context comprises a global object, together with a
set of built-in objects and functions. Running code does not have access to local scope and
the global object held within <code>context</code> will be used as the global object for <code>code</code>.
<code>filename</code> is optional.</p>

<p>Example: compile and execute code in a existing context.</p>

<pre><code>var util = require('util'),
    vm = require('vm'),
    initSandbox = {
      animal: 'cat',
      count: 2
    },
    context = vm.createContext(initSandbox);

vm.runInContext('count += 1; name = "CATT"', context, 'myfile.vm');
console.log(util.inspect(context));

// { animal: 'cat', count: 3, name: 'CATT' }</code></pre>

<p>Note that <code>createContext</code> will perform a shallow clone of the supplied sandbox object in order to
initialise the global object of the freshly constructed context.</p>

<p>Note that running untrusted code is a tricky business requiring great care.  To prevent accidental
global variable leakage, <code>vm.runInContext</code> is quite useful, but safely running untrusted code
requires a separate process.</p>

<p>In case of syntax error in <code>code</code>, <code>vm.runInContext</code> emits the syntax error to stderr
and throws an exception.</p>

<h3 id="vm.createContext">vm.createContext([initSandbox]) <a href="#vm.createContext">#</a></h3>

<p><code>vm.createContext</code> creates a new context which is suitable for use as the 2nd argument of a subsequent
call to <code>vm.runInContext</code>. A (V8) context comprises a global object together with a set of
build-in objects and functions. The optional argument <code>initSandbox</code> will be shallow-copied
to seed the initial contents of the global object used by the context.</p>

<h3 id="vm.createScript">vm.createScript(code, [filename]) <a href="#vm.createScript">#</a></h3>

<p><code>createScript</code> compiles <code>code</code> as if it were loaded from <code>filename</code>,
but does not run it. Instead, it returns a <code>vm.Script</code> object representing this compiled code.
This script can be run later many times using methods below.
The returned script is not bound to any global object.
It is bound before each run, just for that run. <code>filename</code> is optional.</p>

<p>In case of syntax error in <code>code</code>, <code>createScript</code> prints the syntax error to stderr
and throws an exception.</p>

<h3 id="script.runInThisContext">script.runInThisContext() <a href="#script.runInThisContext">#</a></h3>

<p>Similar to <code>vm.runInThisContext</code> but a method of a precompiled <code>Script</code> object.
<code>script.runInThisContext</code> runs the code of <code>script</code> and returns the result.
Running code does not have access to local scope, but does have access to the <code>global</code> object
(v8: in actual context).</p>

<p>Example of using <code>script.runInThisContext</code> to compile code once and run it multiple times:</p>

<pre><code>var vm = require('vm');

globalVar = 0;

var script = vm.createScript('globalVar += 1', 'myfile.vm');

for (var i = 0; i &lt; 1000 ; i += 1) {
  script.runInThisContext();
}

console.log(globalVar);

// 1000</code></pre>

<h3 id="script.runInNewContext">script.runInNewContext([sandbox]) <a href="#script.runInNewContext">#</a></h3>

<p>Similar to <code>vm.runInNewContext</code> a method of a precompiled <code>Script</code> object.
<code>script.runInNewContext</code> runs the code of <code>script</code> with <code>sandbox</code> as the global object and returns the result.
Running code does not have access to local scope. <code>sandbox</code> is optional.</p>

<p>Example: compile code that increments a global variable and sets one, then execute this code multiple times.
These globals are contained in the sandbox.</p>

<pre><code>var util = require('util'),
    vm = require('vm'),
    sandbox = {
      animal: 'cat',
      count: 2
    };

var script = vm.createScript('count += 1; name = "kitty"', 'myfile.vm');

for (var i = 0; i &lt; 10 ; i += 1) {
  script.runInNewContext(sandbox);
}

console.log(util.inspect(sandbox));

// { animal: 'cat', count: 12, name: 'kitty' }</code></pre>

<p>Note that running untrusted code is a tricky business requiring great care.  To prevent accidental
global variable leakage, <code>script.runInNewContext</code> is quite useful, but safely running untrusted code
requires a separate process.</p>

<h2 id="child_Processes">Child Processes</h2>

<p>Node provides a tri-directional <code>popen(3)</code> facility through the <code>ChildProcess</code>
class.</p>

<p>It is possible to stream data through the child's <code>stdin</code>, <code>stdout</code>, and
<code>stderr</code> in a fully non-blocking way.</p>

<p>To create a child process use <code>require('child_process').spawn()</code>.</p>

<p>Child processes always have three streams associated with them. <code>child.stdin</code>,
<code>child.stdout</code>, and <code>child.stderr</code>.</p>

<p><code>ChildProcess</code> is an <code>EventEmitter</code>.</p>

<h3 id="event_exit_">Event:  'exit' <a href="#event_exit_">#</a></h3>

<p><code>function (code, signal) {}</code></p>

<p>This event is emitted after the child process ends. If the process terminated
normally, <code>code</code> is the final exit code of the process, otherwise <code>null</code>. If
the process terminated due to receipt of a signal, <code>signal</code> is the string name
of the signal, otherwise <code>null</code>.</p>

<p>See <code>waitpid(2)</code>.</p>

<h3 id="child.stdin">child.stdin <a href="#child.stdin">#</a></h3>

<p>A <code>Writable Stream</code> that represents the child process's <code>stdin</code>.
Closing this stream via <code>end()</code> often causes the child process to terminate.</p>

<h3 id="child.stdout">child.stdout <a href="#child.stdout">#</a></h3>

<p>A <code>Readable Stream</code> that represents the child process's <code>stdout</code>.</p>

<h3 id="child.stderr">child.stderr <a href="#child.stderr">#</a></h3>

<p>A <code>Readable Stream</code> that represents the child process's <code>stderr</code>.</p>

<h3 id="child.pid">child.pid <a href="#child.pid">#</a></h3>

<p>The PID of the child process.</p>

<p>Example:</p>

<pre><code>var spawn = require('child_process').spawn,
    grep  = spawn('grep', ['ssh']);

console.log('Spawned child pid: ' + grep.pid);
grep.stdin.end();</code></pre>

<h3 id="child_process.spawn">child_process.spawn(command, [args], [options]) <a href="#child_process.spawn">#</a></h3>

<p>Launches a new process with the given <code>command</code>, with  command line arguments in <code>args</code>.
If omitted, <code>args</code> defaults to an empty Array.</p>

<p>The third argument is used to specify additional options, which defaults to:</p>

<pre><code>{ cwd: undefined,
  env: process.env,
  setsid: false
}</code></pre>

<p><code>cwd</code> allows you to specify the working directory from which the process is spawned.
Use <code>env</code> to specify environment variables that will be visible to the new process.</p>

<p><code>setsid</code>, if set true, will cause the subprocess to be run in a new session.</p>

<p>Example of running <code>ls -lh /usr</code>, capturing <code>stdout</code>, <code>stderr</code>, and the exit code:</p>

<pre><code>var util  = require('util'),
    spawn = require('child_process').spawn,
    ls    = spawn('ls', ['-lh', '/usr']);

ls.stdout.on('data', function (data) {
  console.log('stdout: ' + data);
});

ls.stderr.on('data', function (data) {
  console.log('stderr: ' + data);
});

ls.on('exit', function (code) {
  console.log('child process exited with code ' + code);
});</code></pre>

<p>Example: A very elaborate way to run 'ps ax | grep ssh'</p>

<pre><code>var util  = require('util'),
    spawn = require('child_process').spawn,
    ps    = spawn('ps', ['ax']),
    grep  = spawn('grep', ['ssh']);

ps.stdout.on('data', function (data) {
  grep.stdin.write(data);
});

ps.stderr.on('data', function (data) {
  console.log('ps stderr: ' + data);
});

ps.on('exit', function (code) {
  if (code !== 0) {
    console.log('ps process exited with code ' + code);
  }
  grep.stdin.end();
});

grep.stdout.on('data', function (data) {
  console.log(data);
});

grep.stderr.on('data', function (data) {
  console.log('grep stderr: ' + data);
});

grep.on('exit', function (code) {
  if (code !== 0) {
    console.log('grep process exited with code ' + code);
  }
});</code></pre>

<p>Example of checking for failed exec:</p>

<pre><code>var spawn = require('child_process').spawn,
    child = spawn('bad_command');

child.stderr.setEncoding('utf8');
child.stderr.on('data', function (data) {
  if (/^execvp\(\)/.test(data)) {
    console.log('Failed to start child process.');
  }
});</code></pre>

<p>Note that if spawn receives an empty options object, it will result in
spawning the process with an empty environment rather than using
<code>process.env</code>. This due to backwards compatibility issues with a deprecated
API.</p>

<p>There is a deprecated option called <code>customFds</code> which allows one to specify
specific file descriptors for the stdio of the child process. This API was
not portable to all platforms and therefore removed.
With <code>customFds</code> it was possible to hook up the new process' [stdin, stdout,
stderr] to existing streams; <code>-1</code> meant that a new stream should be created.
Use at your own risk.</p>

<p>There are several internal options. In particular <code>stdinStream</code>,
<code>stdoutStream</code>, <code>stderrStream</code>. They are for INTERNAL USE ONLY. As with all
undocumented APIs in Node, they should not be used.</p>

<p>See also: <code>child_process.exec()</code></p>

<h3 id="child_process.exec">child_process.exec(command, [options], callback) <a href="#child_process.exec">#</a></h3>

<p>Runs a command in a shell and buffers the output.</p>

<pre><code>var util = require('util'),
    exec = require('child_process').exec,
    child;

child = exec('cat *.js bad_file | wc -l',
  function (error, stdout, stderr) {
    console.log('stdout: ' + stdout);
    console.log('stderr: ' + stderr);
    if (error !== null) {
      console.log('exec error: ' + error);
    }
});</code></pre>

<p>The callback gets the arguments <code>(error, stdout, stderr)</code>. On success, <code>error</code>
will be <code>null</code>.  On error, <code>error</code> will be an instance of <code>Error</code> and <code>err.code</code>
will be the exit code of the child process, and <code>err.signal</code> will be set to the
signal that terminated the process.</p>

<p>There is a second optional argument to specify several options. The default options are</p>

<pre><code>{ encoding: 'utf8',
  timeout: 0,
  maxBuffer: 200*1024,
  killSignal: 'SIGTERM',
  cwd: null,
  env: null }</code></pre>

<p>If <code>timeout</code> is greater than 0, then it will kill the child process
if it runs longer than <code>timeout</code> milliseconds. The child process is killed with
<code>killSignal</code> (default: <code>'SIGTERM'</code>). <code>maxBuffer</code> specifies the largest
amount of data allowed on stdout or stderr - if this value is exceeded then
the child process is killed.</p>

<h3 id="child_process.execFile">child_process.execFile(file, args, options, callback) <a href="#child_process.execFile">#</a></h3>

<p>This is similar to <code>child_process.exec()</code> except it does not execute a
subshell but rather the specified file directly. This makes it slightly
leaner than <code>child_process.exec</code>. It has the same options.</p>

<h3 id="child_process.fork">child_process.fork(modulePath, arguments, options) <a href="#child_process.fork">#</a></h3>

<p>This is a special case of the <code>spawn()</code> functionality for spawning Node
processes. In addition to having all the methods in a normal ChildProcess
instance, the returned object has a communication channel built-in. The
channel is written to with <code>child.send(message, [sendHandle])</code> and messages
are received by a <code>'message'</code> event on the child.</p>

<p>For example:</p>

<pre><code>var cp = require('child_process');

var n = cp.fork(__dirname + '/sub.js');

n.on('message', function(m) {
  console.log('PARENT got message:', m);
});

n.send({ hello: 'world' });</code></pre>

<p>And then the child script, <code>'sub.js'</code> might look like this:</p>

<pre><code>process.on('message', function(m) {
  console.log('CHILD got message:', m);
});

process.send({ foo: 'bar' });</code></pre>

<p>In the child the <code>process</code> object will have a <code>send()</code> method, and <code>process</code>
will emit objects each time it receives a message on its channel.</p>

<p>By default the spawned Node process will have the stdin, stdout, stderr
associated with the parent's.</p>

<p>These child Nodes are still whole new instances of V8. Assume at least 30ms
startup and 10mb memory for each new Node. That is, you cannot create many
thousands of them.</p>

<p>The <code>sendHandle</code> option to <code>child.send()</code> is for sending a handle object to
another process. Child will receive the handle as as second argument to the
<code>message</code> event. Here is an example of sending a handle:</p>

<pre><code>var server = require('net').createServer();
var child = require('child_process').fork(__dirname + '/child.js');
// Open up the server object and send the handle.
server.listen(1337, function() {
  child.send({ server: true }, server._handle);
});</code></pre>

<p>Here is an example of receiving the server handle and sharing it between
processes:</p>

<pre><code>process.on('message', function(m, serverHandle) {
  if (serverHandle) {
    var server = require('net').createServer();
    server.listen(serverHandle);
  }
});</code></pre>

<h3 id="child.kill">child.kill([signal]) <a href="#child.kill">#</a></h3>

<p>Send a signal to the child process. If no argument is given, the process will
be sent <code>'SIGTERM'</code>. See <code>signal(7)</code> for a list of available signals.</p>

<pre><code>var spawn = require('child_process').spawn,
    grep  = spawn('grep', ['ssh']);

grep.on('exit', function (code, signal) {
  console.log('child process terminated due to receipt of signal '+signal);
});

// send SIGHUP to process
grep.kill('SIGHUP');</code></pre>

<p>Note that while the function is called <code>kill</code>, the signal delivered to the child
process may not actually kill it.  <code>kill</code> really just sends a signal to a process.</p>

<p>See <code>kill(2)</code></p>

<h2 id="assert">Assert</h2>

<p>This module is used for writing unit tests for your applications, you can
access it with <code>require('assert')</code>.</p>

<h3 id="assert.fail">assert.fail(actual, expected, message, operator) <a href="#assert.fail">#</a></h3>

<p>Throws an exception that displays the values for <code>actual</code> and <code>expected</code> separated by the provided operator.</p>

<h3 id="assert_assert.ok">assert(value, message), assert.ok(value, [message]) <a href="#assert_assert.ok">#</a></h3>

<p>Tests if value is a <code>true</code> value, it is equivalent to <code>assert.equal(true, value, message);</code></p>

<h3 id="assert.equal">assert.equal(actual, expected, [message]) <a href="#assert.equal">#</a></h3>

<p>Tests shallow, coercive equality with the equal comparison operator ( <code>==</code> ).</p>

<h3 id="assert.notEqual">assert.notEqual(actual, expected, [message]) <a href="#assert.notEqual">#</a></h3>

<p>Tests shallow, coercive non-equality with the not equal comparison operator ( <code>!=</code> ).</p>

<h3 id="assert.deepEqual">assert.deepEqual(actual, expected, [message]) <a href="#assert.deepEqual">#</a></h3>

<p>Tests for deep equality.</p>

<h3 id="assert.notDeepEqual">assert.notDeepEqual(actual, expected, [message]) <a href="#assert.notDeepEqual">#</a></h3>

<p>Tests for any deep inequality.</p>

<h3 id="assert.strictEqual">assert.strictEqual(actual, expected, [message]) <a href="#assert.strictEqual">#</a></h3>

<p>Tests strict equality, as determined by the strict equality operator ( <code>===</code> )</p>

<h3 id="assert.notStrictEqual">assert.notStrictEqual(actual, expected, [message]) <a href="#assert.notStrictEqual">#</a></h3>

<p>Tests strict non-equality, as determined by the strict not equal operator ( <code>!==</code> )</p>

<h3 id="assert.throws">assert.throws(block, [error], [message]) <a href="#assert.throws">#</a></h3>

<p>Expects <code>block</code> to throw an error. <code>error</code> can be constructor, regexp or 
validation function.</p>

<p>Validate instanceof using constructor:</p>

<pre><code>assert.throws(
  function() {
    throw new Error("Wrong value");
  },
  Error
);</code></pre>

<p>Validate error message using RegExp:</p>

<pre><code>assert.throws(
  function() {
    throw new Error("Wrong value");
  },
  /value/
);</code></pre>

<p>Custom error validation:</p>

<pre><code>assert.throws(
  function() {
    throw new Error("Wrong value");
  },
  function(err) {
    if ( (err instanceof Error) &amp;&amp; /value/.test(err) ) {
      return true;
    }
  },
  "unexpected error"
);</code></pre>

<h3 id="assert.doesNotThrow">assert.doesNotThrow(block, [error], [message]) <a href="#assert.doesNotThrow">#</a></h3>

<p>Expects <code>block</code> not to throw an error, see assert.throws for details.</p>

<h3 id="assert.ifError">assert.ifError(value) <a href="#assert.ifError">#</a></h3>

<p>Tests if value is not a false value, throws if it is a true value. Useful when
testing the first argument, <code>error</code> in callbacks.</p>

<h2 id="tTY">TTY</h2>

<p>Use <code>require('tty')</code> to access this module.</p>

<p>Example:</p>

<pre><code>var tty = require('tty');
process.stdin.resume();
tty.setRawMode(true);
process.stdin.on('keypress', function(char, key) {
  if (key &amp;&amp; key.ctrl &amp;&amp; key.name == 'c') {
    console.log('graceful exit');
    process.exit()
  }
});</code></pre>

<h3 id="tty.isatty">tty.isatty(fd) <a href="#tty.isatty">#</a></h3>

<p>Returns <code>true</code> or <code>false</code> depending on if the <code>fd</code> is associated with a
terminal.</p>

<h3 id="tty.setRawMode">tty.setRawMode(mode) <a href="#tty.setRawMode">#</a></h3>

<p><code>mode</code> should be <code>true</code> or <code>false</code>. This sets the properties of the current
process's stdin fd to act either as a raw device or default.</p>

<h3 id="tty.setWindowSize">tty.setWindowSize(fd, row, col) <a href="#tty.setWindowSize">#</a></h3>

<p>This function was removed in v0.6.0.</p>

<h3 id="tty.getWindowSize">tty.getWindowSize(fd) <a href="#tty.getWindowSize">#</a></h3>

<p>This function was removed in v0.6.0. Use <code>process.stdout.getWindowSize()</code>
instead.</p>

<h2 id="zlib">Zlib</h2>

<p>You can access this module with:</p>

<pre><code>var zlib = require('zlib');</code></pre>

<p>This provides bindings to Gzip/Gunzip, Deflate/Inflate, and
DeflateRaw/InflateRaw classes.  Each class takes the same options, and
is a readable/writable Stream.</p>

<h3 id="examples">Examples <a href="#examples">#</a></h3>

<p>Compressing or decompressing a file can be done by piping an
fs.ReadStream into a zlib stream, then into an fs.WriteStream.</p>

<pre><code>var gzip = zlib.createGzip();
var fs = require('fs');
var inp = fs.createReadStream('input.txt');
var out = fs.createWriteStream('input.txt.gz');

inp.pipe(gzip).pipe(out);</code></pre>

<p>Compressing or decompressing data in one step can be done by using
the convenience methods.</p>

<pre><code>var input = '.................................';
zlib.deflate(input, function(err, buffer) {
  if (!err) {
    console.log(buffer.toString('base64'));
  }
});

var buffer = new Buffer('eJzT0yMAAGTvBe8=', 'base64');
zlib.unzip(buffer, function(err, buffer) {
  if (!err) {
    console.log(buffer.toString());
  }
});</code></pre>

<p>To use this module in an HTTP client or server, use the
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3">accept-encoding</a>
on requests, and the
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11">content-encoding</a>
header on responses.</p>

<p><strong>Note: these examples are drastically simplified to show
the basic concept.</strong>  Zlib encoding can be expensive, and the results
ought to be cached.  See <a href="#memory_Usage_Tuning">Memory Usage Tuning</a>
below for more information on the speed/memory/compression
tradeoffs involved in zlib usage.</p>

<pre><code>// client request example
var zlib = require('zlib');
var http = require('http');
var fs = require('fs');
var request = http.get({ host: 'izs.me',
                         path: '/',
                         port: 80,
                         headers: { 'accept-encoding': 'gzip,deflate' } });
request.on('response', function(response) {
  var output = fs.createWriteStream('izs.me_index.html');

  switch (response.headers['content-encoding']) {
    // or, just use zlib.createUnzip() to handle both cases
    case 'gzip':
      response.pipe(zlib.createGunzip()).pipe(output);
      break;
    case 'deflate':
      response.pipe(zlib.createInflate()).pipe(output);
      break;
    default:
      response.pipe(output);
      break;
  }
});

// server example
// Running a gzip operation on every request is quite expensive.
// It would be much more efficient to cache the compressed buffer.
var zlib = require('zlib');
var http = require('http');
var fs = require('fs');
http.createServer(function(request, response) {
  var raw = fs.createReadStream('index.html');
  var acceptEncoding = request.headers['accept-encoding'];
  if (!acceptEncoding) {
    acceptEncoding = '';
  }

  // Note: this is not a conformant accept-encoding parser.
  // See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3
  if (acceptEncoding.match(/\bdeflate\b/)) {
    response.writeHead(200, { 'content-encoding': 'deflate' });
    raw.pipe(zlib.createDeflate()).pipe(response);
  } else if (acceptEncoding.match(/\bgzip\b/)) {
    response.writeHead(200, { 'content-encoding': 'gzip' });
    raw.pipe(zlib.createGzip()).pipe(response);
  } else {
    response.writeHead(200, {});
    raw.pipe(response);
  }
}).listen(1337);</code></pre>

<h3 id="constants">Constants <a href="#constants">#</a></h3>

<p>All of the constants defined in zlib.h are also defined on
<code>require('zlib')</code>.  They are described in more detail in the zlib
documentation.  See <a href="http://zlib.net/manual.html#Constants">http://zlib.net/manual.html#Constants</a>
for more details.</p>

<h3 id="zlib.createGzip">zlib.createGzip([options]) <a href="#zlib.createGzip">#</a></h3>

<p>Returns a new <a href="#zlib.Gzip">Gzip</a> object with an <a href="#options">options</a>.</p>

<h3 id="zlib.createGunzip">zlib.createGunzip([options]) <a href="#zlib.createGunzip">#</a></h3>

<p>Returns a new <a href="#zlib.Gunzip">Gunzip</a> object with an <a href="#options">options</a>.</p>

<h3 id="zlib.createDeflate">zlib.createDeflate([options]) <a href="#zlib.createDeflate">#</a></h3>

<p>Returns a new <a href="#zlib.Deflate">Deflate</a> object with an <a href="#options">options</a>.</p>

<h3 id="zlib.createInflate">zlib.createInflate([options]) <a href="#zlib.createInflate">#</a></h3>

<p>Returns a new <a href="#zlib.Inflate">Inflate</a> object with an <a href="#options">options</a>.</p>

<h3 id="zlib.createDeflateRaw">zlib.createDeflateRaw([options]) <a href="#zlib.createDeflateRaw">#</a></h3>

<p>Returns a new <a href="#zlib.DeflateRaw">DeflateRaw</a> object with an <a href="#options">options</a>.</p>

<h3 id="zlib.createInflateRaw">zlib.createInflateRaw([options]) <a href="#zlib.createInflateRaw">#</a></h3>

<p>Returns a new <a href="#zlib.InflateRaw">InflateRaw</a> object with an <a href="#options">options</a>.</p>

<h3 id="zlib.createUnzip">zlib.createUnzip([options]) <a href="#zlib.createUnzip">#</a></h3>

<p>Returns a new <a href="#zlib.Unzip">Unzip</a> object with an <a href="#options">options</a>.</p>

<h3 id="zlib.Gzip">zlib.Gzip <a href="#zlib.Gzip">#</a></h3>

<p>Compress data using gzip.</p>

<h3 id="zlib.Gunzip">zlib.Gunzip <a href="#zlib.Gunzip">#</a></h3>

<p>Decompress a gzip stream.</p>

<h3 id="zlib.Deflate">zlib.Deflate <a href="#zlib.Deflate">#</a></h3>

<p>Compress data using deflate.</p>

<h3 id="zlib.Inflate">zlib.Inflate <a href="#zlib.Inflate">#</a></h3>

<p>Decompress a deflate stream.</p>

<h3 id="zlib.DeflateRaw">zlib.DeflateRaw <a href="#zlib.DeflateRaw">#</a></h3>

<p>Compress data using deflate, and do not append a zlib header.</p>

<h3 id="zlib.InflateRaw">zlib.InflateRaw <a href="#zlib.InflateRaw">#</a></h3>

<p>Decompress a raw deflate stream.</p>

<h3 id="zlib.Unzip">zlib.Unzip <a href="#zlib.Unzip">#</a></h3>

<p>Decompress either a Gzip- or Deflate-compressed stream by auto-detecting
the header.</p>

<h2 id="convenience_Methods">Convenience Methods</h2>

<p>All of these take a string or buffer as the first argument, and call the
supplied callback with <code>callback(error, result)</code>.  The
compression/decompression engine is created using the default settings
in all convenience methods.  To supply different options, use the
zlib classes directly.</p>

<h3 id="zlib.deflate">zlib.deflate(buf, callback) <a href="#zlib.deflate">#</a></h3>

<p>Compress a string with Deflate.</p>

<h3 id="zlib.deflateRaw">zlib.deflateRaw(buf, callback) <a href="#zlib.deflateRaw">#</a></h3>

<p>Compress a string with DeflateRaw.</p>

<h3 id="zlib.gzip">zlib.gzip(buf, callback) <a href="#zlib.gzip">#</a></h3>

<p>Compress a string with Gzip.</p>

<h3 id="zlib.gunzip">zlib.gunzip(buf, callback) <a href="#zlib.gunzip">#</a></h3>

<p>Decompress a raw Buffer with Gunzip.</p>

<h3 id="zlib.inflate">zlib.inflate(buf, callback) <a href="#zlib.inflate">#</a></h3>

<p>Decompress a raw Buffer with Inflate.</p>

<h3 id="zlib.inflateRaw">zlib.inflateRaw(buf, callback) <a href="#zlib.inflateRaw">#</a></h3>

<p>Decompress a raw Buffer with InflateRaw.</p>

<h3 id="zlib.unzip">zlib.unzip(buf, callback) <a href="#zlib.unzip">#</a></h3>

<p>Decompress a raw Buffer with Unzip.</p>

<h2 id="options">Options</h2>

<p>Each class takes an options object.  All options are optional.  (The
convenience methods use the default settings for all options.)</p>

<p>Note that some options are only
relevant when compressing, and are ignored by the decompression classes.</p>

<ul><li>chunkSize (default: 16*1024)</li><li>windowBits</li><li>level (compression only)</li><li>memLevel (compression only)</li><li>strategy (compression only)</li></ul>

<p>See the description of <code>deflateInit2</code> and <code>inflateInit2</code> at
<a href="http://zlib.net/manual.html#Advanced">http://zlib.net/manual.html#Advanced</a> for more information on these.</p>

<h3 id="memory_Usage_Tuning">Memory Usage Tuning <a href="#memory_Usage_Tuning">#</a></h3>

<p>From <code>zlib/zconf.h</code>, modified to node's usage:</p>

<p>The memory requirements for deflate are (in bytes):</p>

<pre><code>(1 &lt;&lt; (windowBits+2)) +  (1 &lt;&lt; (memLevel+9))</code></pre>

<p>that is: 128K for windowBits=15  +  128K for memLevel = 8
(default values) plus a few kilobytes for small objects.</p>

<p>For example, if you want to reduce
the default memory requirements from 256K to 128K, set the options to:</p>

<pre><code>{ windowBits: 14, memLevel: 7 }</code></pre>

<p>Of course this will generally degrade compression (there's no free lunch).</p>

<p>The memory requirements for inflate are (in bytes)</p>

<pre><code>1 &lt;&lt; windowBits</code></pre>

<p>that is, 32K for windowBits=15 (default value) plus a few kilobytes
for small objects.</p>

<p>This is in addition to a single internal output slab buffer of size
<code>chunkSize</code>, which defaults to 16K.</p>

<p>The speed of zlib compression is affected most dramatically by the
<code>level</code> setting.  A higher level will result in better compression, but
will take longer to complete.  A lower level will result in less
compression, but will be much faster.</p>

<p>In general, greater memory usage options will mean that node has to make
fewer calls to zlib, since it'll be able to process more data in a
single <code>write</code> operation.  So, this is another factor that affects the
speed, at the cost of memory usage.</p>

<h2 id="os_Module">os Module</h2>

<p>Use <code>require('os')</code> to access this module.</p>

<h3 id="os.hostname">os.hostname() <a href="#os.hostname">#</a></h3>

<p>Returns the hostname of the operating system.</p>

<h3 id="os.type">os.type() <a href="#os.type">#</a></h3>

<p>Returns the operating system name.</p>

<h3 id="os.platform">os.platform() <a href="#os.platform">#</a></h3>

<p>Returns the operating system platform.</p>

<h3 id="os.arch">os.arch() <a href="#os.arch">#</a></h3>

<p>Returns the operating system CPU architecture.</p>

<h3 id="os.release">os.release() <a href="#os.release">#</a></h3>

<p>Returns the operating system release.</p>

<h3 id="os.uptime">os.uptime() <a href="#os.uptime">#</a></h3>

<p>Returns the system uptime in seconds.</p>

<h3 id="os.loadavg">os.loadavg() <a href="#os.loadavg">#</a></h3>

<p>Returns an array containing the 1, 5, and 15 minute load averages.</p>

<h3 id="os.totalmem">os.totalmem() <a href="#os.totalmem">#</a></h3>

<p>Returns the total amount of system memory in bytes.</p>

<h3 id="os.freemem">os.freemem() <a href="#os.freemem">#</a></h3>

<p>Returns the amount of free system memory in bytes.</p>

<h3 id="os.cpus">os.cpus() <a href="#os.cpus">#</a></h3>

<p>Returns an array of objects containing information about each CPU/core installed: model, speed (in MHz), and times (an object containing the number of CPU ticks spent in: user, nice, sys, idle, and irq).</p>

<p>Example inspection of os.cpus:</p>

<pre><code>[ { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
    speed: 2926,
    times:
     { user: 252020,
       nice: 0,
       sys: 30340,
       idle: 1070356870,
       irq: 0 } },
  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
    speed: 2926,
    times:
     { user: 306960,
       nice: 0,
       sys: 26980,
       idle: 1071569080,
       irq: 0 } },
  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
    speed: 2926,
    times:
     { user: 248450,
       nice: 0,
       sys: 21750,
       idle: 1070919370,
       irq: 0 } },
  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
    speed: 2926,
    times:
     { user: 256880,
       nice: 0,
       sys: 19430,
       idle: 1070905480,
       irq: 20 } },
  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
    speed: 2926,
    times:
     { user: 511580,
       nice: 20,
       sys: 40900,
       idle: 1070842510,
       irq: 0 } },
  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
    speed: 2926,
    times:
     { user: 291660,
       nice: 0,
       sys: 34360,
       idle: 1070888000,
       irq: 10 } },
  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
    speed: 2926,
    times:
     { user: 308260,
       nice: 0,
       sys: 55410,
       idle: 1071129970,
       irq: 880 } },
  { model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
    speed: 2926,
    times:
     { user: 266450,
       nice: 1480,
       sys: 34920,
       idle: 1072572010,
       irq: 30 } } ]</code></pre>

<h3 id="os.networkInterfaces">os.networkInterfaces() <a href="#os.networkInterfaces">#</a></h3>

<p>Get a list of network interfaces:</p>

<pre><code>{ lo0: 
   [ { address: '::1', family: 'IPv6', internal: true },
     { address: 'fe80::1', family: 'IPv6', internal: true },
     { address: '127.0.0.1', family: 'IPv4', internal: true } ],
  en1: 
   [ { address: 'fe80::cabc:c8ff:feef:f996', family: 'IPv6',
       internal: false },
     { address: '10.0.1.123', family: 'IPv4', internal: false } ],
  vmnet1: [ { address: '10.99.99.254', family: 'IPv4', internal: false } ],
  vmnet8: [ { address: '10.88.88.1', family: 'IPv4', internal: false } ],
  ppp0: [ { address: '10.2.0.231', family: 'IPv4', internal: false } ] }</code></pre>

<h2 id="debugger">Debugger</h2>

<p>V8 comes with an extensive debugger which is accessible out-of-process via a
simple <a href="http://code.google.com/p/v8/wiki/DebuggerProtocol">TCP protocol</a>.
Node has a built-in client for this debugger. To use this, start Node with the
<code>debug</code> argument; a prompt will appear:</p>

<pre><code>% node debug myscript.js
&lt; debugger listening on port 5858
connecting... ok
break in /home/indutny/Code/git/indutny/myscript.js:1
  1 x = 5;
  2 setTimeout(function () {
  3   debugger;
debug&gt;</code></pre>

<p>Node's debugger client doesn't support the full range of commands, but
simple step and inspection is possible. By putting the statement <code>debugger;</code>
into the source code of your script, you will enable a breakpoint.</p>

<p>For example, suppose <code>myscript.js</code> looked like this:</p>

<pre><code>// myscript.js
x = 5;
setTimeout(function () {
  debugger;
  console.log("world");
}, 1000);
console.log("hello");</code></pre>

<p>Then once the debugger is run, it will break on line 4.</p>

<pre><code>% node debug myscript.js
&lt; debugger listening on port 5858
connecting... ok
break in /home/indutny/Code/git/indutny/myscript.js:1
  1 x = 5;
  2 setTimeout(function () {
  3   debugger;
debug&gt; cont
&lt; hello
break in /home/indutny/Code/git/indutny/myscript.js:3
  1 x = 5;
  2 setTimeout(function () {
  3   debugger;
  4   console.log("world");
  5 }, 1000);
debug&gt; next
break in /home/indutny/Code/git/indutny/myscript.js:4
  2 setTimeout(function () {
  3   debugger;
  4   console.log("world");
  5 }, 1000);
  6 console.log("hello");
debug&gt; repl
Press Ctrl + C to leave debug repl
&gt; x
5
&gt; 2+2
4
debug&gt; next
&lt; world
break in /home/indutny/Code/git/indutny/myscript.js:5
  3   debugger;
  4   console.log("world");
  5 }, 1000);
  6 console.log("hello");
  7
debug&gt; quit
%</code></pre>

<p>The <code>repl</code> command allows you to evaluate code remotely. The <code>next</code> command
steps over to the next line. There are a few other commands available and more
to come. Type <code>help</code> to see others.</p>

<h3 id="watchers">Watchers <a href="#watchers">#</a></h3>

<p>You can watch expression and variable values while debugging your code.
On every breakpoint each expression from the watchers list will be evaluated
in the current context and displayed just before the breakpoint's source code
listing.</p>

<p>To start watching an expression, type <code>watch("my_expression")</code>. <code>watchers</code>
prints the active watchers. To remove a watcher, type
<code>unwatch("my_expression")</code>.</p>

<h3 id="commands_reference">Commands reference <a href="#commands_reference">#</a></h3>

<h4 id="stepping">Stepping <a href="#stepping">#</a></h4>

<ul><li><code>cont</code>, <code>c</code> - Continue execution</li><li><code>next</code>, <code>n</code> - Step next</li><li><code>step</code>, <code>s</code> - Step in</li><li><code>out</code>, <code>o</code> - Step out</li></ul>

<h4 id="breakpoints">Breakpoints <a href="#breakpoints">#</a></h4>

<ul><li><code>setBreakpoint()</code>, <code>sb()</code> - Set breakpoint on current line</li><li><code>setBreakpoint('fn()')</code>, <code>sb(...)</code> - Set breakpoint on a first statement in
functions body</li><li><code>setBreakpoint('script.js', 1)</code>, <code>sb(...)</code> - Set breakpoint on first line of
script.js</li><li><code>clearBreakpoint</code>, <code>cb(...)</code> - Clear breakpoint</li></ul>

<h4 id="info">Info <a href="#info">#</a></h4>

<ul><li><code>backtrace</code>, <code>bt</code> - Print backtrace of current execution frame</li><li><code>list(5)</code> - List scripts source code with 5 line context (5 lines before and
after)</li><li><code>watch(expr)</code> - Add expression to watch list</li><li><code>unwatch(expr)</code> - Remove expression from watch list</li><li><code>watchers</code> - List all watchers and their values (automatically listed on each
breakpoint)</li><li><code>repl</code> - Open debugger's repl for evaluation in debugging script's context</li></ul>

<h4 id="execution_control">Execution control <a href="#execution_control">#</a></h4>

<ul><li><code>run</code> - Run script (automatically runs on debugger's start)</li><li><code>restart</code> - Restart script</li><li><code>kill</code> - Kill script</li></ul>

<h4 id="various">Various <a href="#various">#</a></h4>

<ul><li><code>scripts</code> - List all loaded scripts</li><li><code>version</code> - Display v8's version</li></ul>

<h3 id="advanced_Usage">Advanced Usage <a href="#advanced_Usage">#</a></h3>

<p>The V8 debugger can be enabled and accessed either by starting Node with
the <code>--debug</code> command-line flag or by signaling an existing Node process
with <code>SIGUSR1</code>.</p>

<h2 id="cluster">Cluster</h2>

<p>A single instance of Node runs in a single thread. To take advantage of
multi-core systems the user will sometimes want to launch a cluster of Node
processes to handle the load.</p>

<p>The cluster module allows you to easily create a network of processes that
all share server ports.</p>

<pre><code>var cluster = require('cluster');
var http = require('http');
var numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  // Fork workers.
  for (var i = 0; i &lt; numCPUs; i++) {
    cluster.fork();
  }

  cluster.on('death', function(worker) {
    console.log('worker ' + worker.pid + ' died');
  });
} else {
  // Worker processes have a http server.
  http.Server(function(req, res) {
    res.writeHead(200);
    res.end("hello world\n");
  }).listen(8000);
}</code></pre>

<p>Running node will now share port 8000 between the workers:</p>

<pre><code>% node server.js
Worker 2438 online
Worker 2437 online</code></pre>

<p>The difference between <code>cluster.fork()</code> and <code>child_process.fork()</code> is simply
that cluster allows TCP servers to be shared between workers. <code>cluster.fork</code>
is implemented on top of <code>child_process.fork</code>. The message passing API that
is available with <code>child_process.fork</code> is available with <code>cluster</code> as well.
As an example, here is a cluster which keeps count of the number of requests
in the master process via message passing:</p>

<pre><code>var cluster = require('cluster');
var http = require('http');
var numReqs = 0;

if (cluster.isMaster) {
  // Fork workers.
  for (var i = 0; i &lt; 2; i++) {
    var worker = cluster.fork();

    worker.on('message', function(msg) {
      if (msg.cmd &amp;&amp; msg.cmd == 'notifyRequest') {
        numReqs++;
      }
    });
  }

  setInterval(function() {
    console.log("numReqs =", numReqs);
  }, 1000);
} else {
  // Worker processes have a http server.
  http.Server(function(req, res) {
    res.writeHead(200);
    res.end("hello world\n");
    // Send message to master process
    process.send({ cmd: 'notifyRequest' });
  }).listen(8000);
}</code></pre>

<h3 id="cluster.fork">cluster.fork() <a href="#cluster.fork">#</a></h3>

<p>Spawn a new worker process. This can only be called from the master process.</p>

<h3 id="cluster.isMaster">cluster.isMaster <a href="#cluster.isMaster">#</a></h3>

<h3 id="cluster.isWorker">cluster.isWorker <a href="#cluster.isWorker">#</a></h3>

<p>Boolean flags to determine if the current process is a master or a worker
process in a cluster. A process <code>isMaster</code> if <code>process.env.NODE_WORKER_ID</code>
is undefined.</p>

<h3 id="event_death_">Event: 'death' <a href="#event_death_">#</a></h3>

<p>When any of the workers die the cluster module will emit the 'death' event.
This can be used to restart the worker by calling <code>fork()</code> again.</p>

<pre><code>cluster.on('death', function(worker) {
  console.log('worker ' + worker.pid + ' died. restart...');
  cluster.fork();
});</code></pre>

<p>Different techniques can be used to restart the worker depending on the
application.</p>

<h1>Appendixes</h1>

<h2 id="appendix_1_Third_Party_Modules">Appendix 1 - Third Party Modules</h2>

<p>There are many third party modules for Node. At the time of writing, August
2010, the master repository of modules is
<a href="https://github.com/joyent/node/wiki/modules">the wiki page</a>.</p>

<p>This appendix is intended as a SMALL guide to new-comers to help them
quickly find what are considered to be quality modules. It is not intended
to be a complete list.  There may be better more complete modules found
elsewhere.</p>

<ul><li><p>Module Installer: <a href="https://github.com/isaacs/npm">npm</a></p></li><li><p>HTTP Middleware: <a href="https://github.com/senchalabs/connect">Connect</a></p></li><li><p>Web Framework: <a href="https://github.com/visionmedia/express">Express</a></p></li><li><p>Web Sockets: <a href="https://github.com/learnboost/socket.io">Socket.IO</a></p></li><li><p>HTML Parsing: <a href="https://github.com/aredridel/html5">HTML5</a></p></li><li><p><a href="https://github.com/agnat/node_mdns">mDNS/Zeroconf/Bonjour</a></p></li><li><p><a href="https://github.com/postwait/node-amqp">RabbitMQ, AMQP</a></p></li><li><p><a href="https://github.com/felixge/node-mysql">mysql</a></p></li><li><p>Serialization: <a href="https://github.com/pgriess/node-msgpack">msgpack</a></p></li><li><p>Scraping: <a href="https://github.com/silentrob/Apricot">Apricot</a></p></li><li><p>Debugger: <a href="https://github.com/smtlaissezfaire/ndb">ndb</a> is a CLI debugger
<a href="https://github.com/dannycoates/node-inspector">inspector</a> is a web based
tool.</p></li><li><p><a href="https://github.com/mranney/node_pcap">pcap binding</a></p></li><li><p><a href="https://github.com/mscdex/node-ncurses">ncurses</a></p></li><li><p>Testing/TDD/BDD: <a href="http://vowsjs.org/">vows</a>,
<a href="https://github.com/visionmedia/expresso">expresso</a>,
<a href="https://github.com/tmpvar/mjsunit.runner">mjsunit.runner</a></p></li></ul>

<p>Patches to this list are welcome.</p>
  </div>
  <script src="assets/sh_main.js"></script>
  <script src="assets/sh_javascript.min.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>
  <script>
    var gaJsHost = (("https:" == document.location.protocol) ?
    "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
  </script>
  <script>
    try {
      var pageTracker = _gat._getTracker("UA-10874194-2");
      pageTracker._trackPageview();
      } catch(err) {}</script>
</body>
</html>
